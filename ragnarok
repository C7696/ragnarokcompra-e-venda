// ==UserScript==
// @name         Ragnarok
// @namespace    http://tampermonkey.net/
// @version      0.0.1
// @description  [PT/RU/EN] Enhanced market interface with Firebase authorization, user inputs, save, multi-language, effects, Gemini AI - Workers & LZString. Persists session across reloads.
// @match        https://*.tribalwars.com.br/game.php?village=*&screen=market&mode=exchange
// @match        https://*.tribalwars.us/game.php?village=*&screen=market&mode=exchange
// @match        https://*.tribalwars.com.br/game.php?t=*&village=*&screen=market&mode=exchange
// @connect      firebaseio.com
// @connect      cloudfunctions.net
// @connect      googleapis.com
// @connect      gstatic.com
// @require      https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js
// @require      https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js
// @require      https://unpkg.com/i18next@23.15.1/dist/umd/i18next.min.js
// @require      https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js
// @require      https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js
// @require      https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/js/all.min.js
// @require      https://cdn.jsdelivr.net/npm/luxon@3.3.0/build/global/luxon.min.js
// @require      https://cdn.jsdelivr.net/npm/axios@1.6.2/dist/axios.min.js
// @require      https://unpkg.com/mobx@6.9.0/dist/mobx.umd.production.min.js
// @require      https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js
// @require      https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js
// @grant        GM_xmlhttpRequest
// @grant        GM_addElement
// @grant        GM_addStyle
// @grant        unsafeWindow
// @grant        GM_getValue
// @grant        GM_setValue
// @grant        GM_deleteValue
// @connect      ip-api.com
// ==/UserScript==


(async function() {
  "use strict";
  const firebaseConfig = {
    apiKey: "AIzaSyAnDVwYDWa_JZj6uApXv6o9_d66JUZwF9o",
    authDomain: "compra-e-venda-ragnarok.firebaseapp.com",
    projectId: "compra-e-venda-ragnarok",
    storageBucket: "compra-e-venda-ragnarok.appspot.com",
    messagingSenderId: "896525993752",
    appId: "1:896525993752:web:1f99c76f66e16669f3c06d",
    measurementId: "G-1B10ECJN01"
  };
  const SCRIPT_NAME = "RAGNAROK_AUTH_SESSION";
  const SESSION_HEARTBEAT_MINUTES = 3;
  const SESSION_VALIDITY_MINUTES = 7;
  const IP_API_URL = "http://ip-api.com/json/?fields=status,message,query,city,country";
  const GM_SESSION_KEY_PREFIX = `${SCRIPT_NAME}_session_`;
  const GM_EXPIRATION_KEY_PREFIX = `${SCRIPT_NAME}_expiration_`;
  let isScriptActive = false;
  let firestoreListenerUnsubscribe = null;
  let sessionHeartbeatTimer = null;
  let currentSessionId = null;
  let currentPlayerNickname = null;
  let cleanupAttempted = false;
  function initializeFirebase() {
    try {
      if (!firebase.apps.length) {
        firebase.initializeApp(firebaseConfig);
      }
      return firebase.firestore();
    } catch (error) {
      alert(`${SCRIPT_NAME}: Falha cr\xEDtica ao inicializar o sistema de verifica\xE7\xE3o. O script n\xE3o pode continuar.`);
      return null;
    }
  }
  function getPlayerNickname() {
    try {
      const nick = TribalWars.getGameData().player.name.toString();
      if (!nick || nick.trim() === "") {
        throw new Error("Nickname do jogador vazio ou inv\xE1lido.");
      }
      return nick;
    } catch (e) {
      return null;
    }
  }
  function generateSessionId() {
    return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
  }
  async function fetchGeoInfo() {
    return new Promise((resolve) => {
      GM_xmlhttpRequest({
        method: "GET",
        url: IP_API_URL,
        timeout: 5e3,
        onload: function(response) {
          if (response.status >= 200 && response.status < 300) {
            try {
              const data = JSON.parse(response.responseText);
              if (data.status === "success") {
                resolve({ ip: data.query, city: data.city, country: data.country });
              } else {
                resolve({ ip: "Erro API", city: "Erro API", country: "Erro API" });
              }
            } catch (e) {
              resolve({ ip: "Erro Parse", city: "Erro Parse", country: "Erro Parse" });
            }
          } else {
            resolve({ ip: `Erro HTTP ${response.status}`, city: `Erro HTTP ${response.status}`, country: `Erro HTTP ${response.status}` });
          }
        },
        onerror: function(error) {
          resolve({ ip: "Erro Rede", city: "Erro Rede", country: "Erro Rede" });
        },
        ontimeout: function() {
          resolve({ ip: "Timeout", city: "Timeout", country: "Timeout" });
        }
      });
    });
  }
  async function checkLicenseAndRegisterSession(playerNickname) {
    if (!playerNickname) {
      return { authorized: false, reason: "Nickname inv\xE1lido fornecido." };
    }
    const db = initializeFirebase();
    if (!db) {
      return { authorized: false, reason: "Firestore n\xE3o inicializado." };
    }
    const newSessionId = generateSessionId();
    const playerDocRef = db.collection("jogadores_permitidos").doc(playerNickname);
    const sessionsColRef = playerDocRef.collection("sessoes_ativas");
    let finalResult = { authorized: false, reason: "Falha desconhecida na verifica\xE7\xE3o.", sessionId: null };
    const FirestoreTimestamp = firebase.firestore.Timestamp;
    try {
      let expirationDate = null;
      await db.runTransaction(async (transaction) => {
        const playerDocSnap = await transaction.get(playerDocRef);
        if (!playerDocSnap.exists) {
          throw new Error("Nickname n\xE3o encontrado na lista de permiss\xF5es.");
        }
        const playerData = playerDocSnap.data();
        if (!playerData || !playerData.data_expiracao || typeof playerData.data_expiracao.toDate !== "function") {
          throw new Error("Formato da data de expira\xE7\xE3o inv\xE1lido no banco de dados.");
        }
        expirationDate = playerData.data_expiracao.toDate();
        const currentDate = /* @__PURE__ */ new Date();
        if (currentDate >= expirationDate) {
          throw new Error(`Licen\xE7a expirada em ${expirationDate.toLocaleString()}.`);
        }
        const newSessionRef = sessionsColRef.doc(newSessionId);
        const nowTimestamp = FirestoreTimestamp.now();
        const sessionData = {
          timestamp_criacao: nowTimestamp,
          timestamp_heartbeat: nowTimestamp
        };
        transaction.set(newSessionRef, sessionData);
      });
      try {
        const geoInfo = await fetchGeoInfo();
        const sessionRef = sessionsColRef.doc(newSessionId);
        await sessionRef.update({
          ip_registrado: geoInfo.ip || "N/A",
          cidade_registrada: geoInfo.city || "N/A",
          pais_registrado: geoInfo.country || "N/A",
          info_navegador: navigator.userAgent || "N/A"
        });
      } catch (updateError) {
      }
      finalResult = {
        authorized: true,
        reason: "Licen\xE7a OK, Sess\xE3o Registrada.",
        sessionId: newSessionId,
        expirationDate
      };
    } catch (error) {
      finalResult = {
        authorized: false,
        reason: `Falha na verifica\xE7\xE3o: ${error.message}` || "Erro desconhecido na verifica\xE7\xE3o.",
        sessionId: null
      };
    }
    return finalResult;
  }
  async function sendHeartbeat(playerNickname, sessionId) {
    if (!playerNickname || !sessionId) return false;
    const db = initializeFirebase();
    if (!db) return false;
    const sessionRef = db.collection("jogadores_permitidos").doc(playerNickname).collection("sessoes_ativas").doc(sessionId);
    try {
      await sessionRef.update({
        timestamp_heartbeat: firebase.firestore.FieldValue.serverTimestamp()
      });
      return true;
    } catch (error) {
      if (error.code === "not-found") {
        return false;
      }
      throw error;
    }
  }
  async function cleanupSessionOnUnload(playerNick, sessId) {
    if (cleanupAttempted || !playerNick || !sessId) return;
    cleanupAttempted = true;
    const storageKey = GM_SESSION_KEY_PREFIX + playerNick;
    try {
      GM_deleteValue(storageKey);
    } catch (e) {
    }
    const db = initializeFirebase();
    if (!db) return;
    const sessionRef = db.collection("jogadores_permitidos").doc(playerNick).collection("sessoes_ativas").doc(sessId);
    try {
      sessionRef.delete();
    } catch (e) {
    }
  }
  function desativarScript(motivo) {
    if (!isScriptActive && firestoreListenerUnsubscribe === null && sessionHeartbeatTimer === null) {
      return;
    }
    const wasActive = isScriptActive;
    isScriptActive = false;
    if (firestoreListenerUnsubscribe) {
      try {
        firestoreListenerUnsubscribe();
      } catch (e) {
      }
      firestoreListenerUnsubscribe = null;
    }
    if (sessionHeartbeatTimer) {
      clearInterval(sessionHeartbeatTimer);
      sessionHeartbeatTimer = null;
    }
    if (wasActive && currentPlayerNickname) {
      const storageKey = GM_SESSION_KEY_PREFIX + currentPlayerNickname;
      try {
        GM_deleteValue(storageKey);
      } catch (e) {
      }
    }
    if (currentPlayerNickname && currentSessionId) {
      const db = initializeFirebase();
      if (db) {
        db.collection("jogadores_permitidos").doc(currentPlayerNickname).collection("sessoes_ativas").doc(currentSessionId).delete().catch((err) => {
        });
      }
    }
    currentSessionId = null;
    alert(`RAGNAROK: O script foi desativado.
Motivo: ${motivo}

Recarregue a p\xE1gina se o problema for resolvido.`);
    try {
      const container = document.querySelector(".market-container");
      if (container) {
        container.querySelectorAll("button, input, select, textarea").forEach((el) => el.disabled = true);
        let overlay = container.querySelector(".ragnarok-disabled-overlay");
        if (!overlay) {
          overlay = document.createElement("div");
          overlay.className = "ragnarok-disabled-overlay";
          overlay.style.position = "absolute";
          overlay.style.top = "0";
          overlay.style.left = "0";
          overlay.style.width = "100%";
          overlay.style.height = "100%";
          overlay.style.background = "rgba(100, 100, 100, 0.7)";
          overlay.style.color = "white";
          overlay.style.zIndex = "1000";
          overlay.style.display = "flex";
          overlay.style.flexDirection = "column";
          overlay.style.justifyContent = "center";
          overlay.style.alignItems = "center";
          overlay.style.fontSize = "18px";
          overlay.style.textAlign = "center";
          overlay.style.backdropFilter = "blur(2px)";
          overlay.style.borderRadius = "15px";
          overlay.innerHTML = `Script RAGNAROK Desativado<br><small style="font-size: 12px;">(${motivo})</small>`;
          container.style.position = "relative";
          container.appendChild(overlay);
        }
      }
    } catch (e) {
    }
  }
  async function iniciarMonitoramentoRealtimeEHeartbeat(playerNickname, sessionId) {
    if (!playerNickname || !sessionId) {
      desativarScript("Erro interno: Falta de dados para iniciar monitoramento.");
      return;
    }
    const db = initializeFirebase();
    if (!db) {
      desativarScript("Erro cr\xEDtico: Firestore indispon\xEDvel.");
      return;
    }
    const playerDocRef = db.collection("jogadores_permitidos").doc(playerNickname);
    firestoreListenerUnsubscribe = playerDocRef.onSnapshot(
      (docSnap) => {
        if (!isScriptActive) return;
        if (!docSnap.exists || !docSnap.data()?.data_expiracao?.toDate()) {
          desativarScript("Licen\xE7a revogada ou inv\xE1lida.");
          return;
        }
        const expirationDate = docSnap.data().data_expiracao.toDate();
        if (/* @__PURE__ */ new Date() >= expirationDate) {
          desativarScript(`Licen\xE7a expirou em ${expirationDate.toLocaleString()}.`);
        }
      },
      (error) => desativarScript(`Erro de conex\xE3o no monitoramento (${error.code}).`)
    );
    sessionHeartbeatTimer = setInterval(async () => {
      try {
        const success = await sendHeartbeat(playerNickname, sessionId);
        if (!success && isScriptActive) {
          const checkResult = await checkLicenseAndRegisterSession(playerNickname);
          if (checkResult.authorized && checkResult.sessionId) {
            currentSessionId = checkResult.sessionId;
          } else {
            desativarScript(checkResult.reason || "Falha ao recriar sess\xE3o.");
          }
        }
      } catch (error) {
        desativarScript(`Erro de comunica\xE7\xE3o com o servidor (${error.code || "desconhecido"}).`);
      }
    }, SESSION_HEARTBEAT_MINUTES * 60 * 1e3);
    window.addEventListener("beforeunload", () => cleanupSessionOnUnload(playerNickname, sessionId));
  }
  function getStoredExpiration(nickname) {
    const key = GM_EXPIRATION_KEY_PREFIX + nickname;
    const storedExpiration = GM_getValue(key);
    if (storedExpiration) {
      const expirationDate = new Date(storedExpiration);
      if (!isNaN(expirationDate.getTime())) {
        return expirationDate;
      }
    }
    return null;
  }
  function storeExpiration(nickname, expirationDate) {
    const key = GM_EXPIRATION_KEY_PREFIX + nickname;
    GM_setValue(key, expirationDate.toISOString());
  }
  async function verificarLicenca() {
    currentPlayerNickname = getPlayerNickname();
    if (!currentPlayerNickname) {
      desativarScript("N\xE3o foi poss\xEDvel identificar o Nickname.");
      return false;
    }
    const storedExpiration = getStoredExpiration(currentPlayerNickname);
    const currentDate = /* @__PURE__ */ new Date();
    if (storedExpiration && currentDate < storedExpiration) {
      currentSessionId = GM_getValue(GM_SESSION_KEY_PREFIX + currentPlayerNickname)?.sessionId || generateSessionId();
      return true;
    }
    const checkResult = await checkLicenseAndRegisterSession(currentPlayerNickname);
    if (checkResult.authorized && checkResult.sessionId && checkResult.expirationDate) {
      storeExpiration(currentPlayerNickname, checkResult.expirationDate);
      currentSessionId = checkResult.sessionId;
      const storageKey = GM_SESSION_KEY_PREFIX + currentPlayerNickname;
      GM_setValue(storageKey, { sessionId: currentSessionId, timestamp: Date.now(), expirationDate: checkResult.expirationDate.toISOString() });
      return true;
    } else {
      desativarScript(checkResult.reason || "Falha na verifica\xE7\xE3o da licen\xE7a.");
      return false;
    }
  }
  if (typeof firebase === "undefined" || typeof firebase.firestore === "undefined") {
    alert(`${SCRIPT_NAME}: Erro cr\xEDtico - Componentes de verifica\xE7\xE3o n\xE3o encontrados.`);
    return;
  }
  const licencaValida = await verificarLicenca();
  if (!licencaValida) {
    return;
  }
  isScriptActive = true;
  iniciarMonitoramentoRealtimeEHeartbeat(currentPlayerNickname, currentSessionId);
  let isSellCooldownActive = false;
  const SELL_COOLDOWN_MS = 6e3;
  const VOLATILITY_WINDOW = 5;
  const TREND_SENSITIVITY = 0.05;
  const _ = window._;
  const DateTime = luxon.DateTime;
  if (typeof axios === "undefined") {
    return;
  }
  const mobx = window.mobx;
  const GEMINI_API_KEY = "";
  const GEMINI_API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent";
  const requestCache = {
    cache: {},
    cacheLimit: 100,
    cacheKeys: [],
    get: function(url) {
      if (this.cache[url]) {
        this.cacheKeys = _.filter(this.cacheKeys, (key) => key !== url);
        this.cacheKeys.push(url);
        return this.cache[url].data;
      }
      return void 0;
    },
    set: function(url, data) {
      if (this.cache[url]) {
        this.cache[url].data = data;
        this.cacheKeys = _.filter(this.cacheKeys, (key) => key !== url);
        this.cacheKeys.push(url);
      } else {
        if (this.cacheKeys.length >= this.cacheLimit) {
          const oldestKey = this.cacheKeys.shift();
          delete this.cache[oldestKey];
        }
        this.cache[url] = { data };
        this.cacheKeys.push(url);
      }
    }
  };
  async function fetchMarketData(url) {
    const cachedData = requestCache.get(url);
    if (cachedData) {
      return cachedData;
    }
    try {
      const response = await axios.get(url, {
        headers: { "X-Requested-With": "XMLHttpRequest" },
        timeout: 5e3
      });
      requestCache.set(url, response.data);
      return response.data;
    } catch (error) {
      return null;
    }
  }
   const translations = {
    resources: {
      pt: {
        translation: {
          // --- Traduções Existentes (Mantidas) ---
          title: "RAGNAROK COMPRA E VENDA DE RECURSOS",
          buyModeToggleOn: "Desativar Compra",
          buyModeToggleOff: "Habilitar Compra",
          sellModeToggleOn: "Desativar Venda",
          sellModeToggleOff: "Habilitar Venda",
          saveConfig: "\u{1F4BE} Salvar",
          resetAll: "Resetar Tudo",
          pause: "Pausar",
          transactions: "Transa\xE7\xF5es",
          aiAssistant: "Assistente IA Ragnarok", // Adicionado um título para IA
          settings: "Configura\xE7\xF5es",
          saveSuccess: "Configura\xE7\xE3o salva com sucesso!",
          portuguese: "Portugu\xEAs",
          russian: "Russo",
          english: "Ingl\xEAs",
          activated: "Ativado",
          deactivated: "Deativado",
          transactionInProgress: "Processando transa\xE7\xE3o...",
          transactionSuccess: "Transa\xE7\xE3o conclu\xEDda com sucesso!",
          transactionError: "Erro na transa\xE7\xE3o. Tente novamente.",
          domError: "Erro ao acessar elementos do jogo. Atualizando...",
          noTransactions: "Nenhuma transa\xE7\xE3o encontrada.",
          transactionsHeader: "Hist\xF3rico de Transa\xE7\xF5es",
          transaction: "Transa\xE7\xE3o",
          date: "Data",
          type: "Tipo",
          change: "Mudan\xE7a",
          newPremiumPoints: "Novos Pontos Premium",
          close: "Fechar",
          filters: "Filtros",
          dateFrom: "Data Inicial",
          dateTo: "Data Final",
          worldFilter: "Filtro por Mundo",
          sortAsc: "Ordenar Ascendente",
          sortDesc: "Ordenar Descendente",
          page: "P\xE1gina",
          next: "Pr\xF3ximo",
          previous: "Anterior",
          chartTitle: "Mudan\xE7as ao Longo do Tempo",
          expenses: "Despesas",
          sales: "Lucros",
          profit: "Lucro",
          aiPrompt: "Digite sua pergunta para o Assistente IA",
          aiLoading: "Carregando resposta...",
          aiError: "Erro ao obter resposta do AI",
          minimize: "Minimizar",
          stockDesiredTooltip: "Define a quantidade máxima de {resource}, considerando a soma dos recursos disponíveis na aldeia e os recursos em trânsito.",
          userRateTooltip: "Taxa m\xEDnima (pontos premium por unidade) para comprar {resource}. O script s\xF3 compra se o mercado for igual ou maior.",
          buyPerTimeTooltip: "Quantidade m\xE1xima de {resource} por compra. O script n\xE3o excede esse valor por transa\xE7\xE3o.",
          reserveAmountTooltip: "Quantidade m\xEDnima de {resource} a manter. O script n\xE3o vende se o estoque for igual ou menor.",
          reserveRateTooltip: "Taxa m\xE1xima (pontos premium por unidade) para vender {resource}. O script s\xF3 vende se o mercado for igual ou menor.",
          sellLimitTooltip: "Quantidade m\xE1xima de {resource} por venda. O script n\xE3o excede esse valor por transa\xE7\xE3o.",
          resourceNames: {
            wood: "madeira",
            stone: "argila",
            iron: "ferro"
          },

          // --- NOVAS Traduções para a Modal de Configurações ---
          settingsSectionAccount: "Informações da Conta",
          settingsSectionLanguage: "Idioma",
          settingsSectionGeneral: "Geral",
          settingsSectionSell: "Venda",
          // Adicionar mais seções aqui (ex: settingsSectionBuy: "Compra")
          settingsLabelPlayer: "Jogador:",
          settingsLabelLicense: "Licença Expira em:",
          settingsLabelVersion: "Versão do Script:",
          settingsLabelInterfaceLang: "Idioma da Interface:",
          settingsLabelCheckInterval: "Intervalo Verificação (seg):",
          settingsLabelAutoReload: "Recarregar em erro:",
          settingsLabelSellCooldown: "Cooldown Venda (seg):",
          settingsLabelMerchantReserve: "Reserva de Mercadores:",
          // Adicionar mais labels aqui
          tooltipCheckInterval: "Frequência (em segundos) com que o script verifica o mercado e executa ações.",
          tooltipAutoReload: "Se marcado, a página será recarregada automaticamente se ocorrer um erro ao confirmar uma transação.",
          tooltipSellCooldown: "Tempo mínimo (em segundos) de espera após uma venda antes de tentar vender novamente.",
          tooltipMerchantReserve: "Número de mercadores que o script deve deixar sempre livres para uso manual.",
          // Adicionar mais tooltips aqui
        }
      },
      ru: {
        translation: {
          // --- Traduções Existentes (Mantidas) ---
          title: "\u0420\u0410\u0413\u041D\u0410\u0420\u041E\u041A \u041F\u041E\u041A\u0423\u041F\u041A\u0410 \u0418 \u041F\u0420\u041E\u0414\u0410\u0416\u0410 \u0420\u0415\u0421\u0423\u0420\u0421\u041E\u0412",
          buyModeToggleOn: "\u041E\u0442\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u043F\u043E\u043A\u0443\u043F\u043A\u0443",
          buyModeToggleOff: "\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u043F\u043E\u043A\u0443\u043F\u043A\u0443",
          sellModeToggleOn: "\u041E\u0442\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u043F\u0440\u043E\u0434\u0430\u0436\u0443",
          sellModeToggleOff: "\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u043F\u0440\u043E\u0434\u0430\u0436\u0443",
          saveConfig: "\u{1F4BE} \u0421\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C",
          resetAll: "\u0421\u0431\u0440\u043E\u0441\u0438\u0442\u044C \u0432\u0441\u0451",
          pause: "\u041F\u0430\u0443\u0437\u0430",
          transactions: "\u0422\u0440\u0430\u043D\u0437\u0430\u043A\u0446\u0438\u0438",
          aiAssistant: "\u0418\u0418-\u0410\u0441\u0441\u0438\u0441\u0442\u0435\u043D\u0442 \u0420\u0430\u0433\u043D\u0430\u0440\u043E\u043A",
          settings: "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438",
          saveSuccess: "\u041A\u043E\u043D\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044F \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0430!",
          portuguese: "\u041F\u043E\u0440\u0442\u0443\u0433\u0430\u043B\u044C\u0441\u043A\u0438\u0439",
          russian: "\u0420\u0443\u0441\u0441\u043A\u0438\u0439",
          english: "\u0410\u043D\u0433\u043B\u0438\u0439\u0441\u043A\u0438\u0439",
          activated: "\u0410\u043A\u0442\u0438\u0432\u0438\u0440\u043E\u0432\u0430\u043D\u043E",
          deactivated: "\u0414\u0435\u0430\u043A\u0442\u0438\u0432\u0438\u0440\u043E\u0432\u0430\u043D\u043E",
          transactionInProgress: "\u041E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0430 \u0442\u0440\u0430\u043D\u0437\u0430\u043A\u0446\u0438\u0438...",
          transactionSuccess: "\u0422\u0440\u0430\u043D\u0437\u0430\u043A\u0446\u0438\u044F \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u0430!",
          transactionError: "\u041E\u0448\u0438\u0431\u043A\u0430 \u0442\u0440\u0430\u043D\u0437\u0430\u043A\u0446\u0438\u0438. \u041F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u0441\u043D\u043E\u0432\u0430.",
          domError: "\u041E\u0448\u0438\u0431\u043A\u0430 \u0434\u043E\u0441\u0442\u0443\u043F\u0430 \u043A \u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u043C \u0438\u0433\u0440\u044B. \u041E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u0435...",
          noTransactions: "\u0422\u0440\u0430\u043D\u0437\u0430\u043A\u0446\u0438\u0439 \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u043E.",
          transactionsHeader: "\u0418\u0441\u0442\u043E\u0440\u0438\u044F \u0442\u0440\u0430\u043D\u0437\u0430\u043A\u0446\u0438\u0439",
          transaction: "\u0422\u0440\u0430\u043D\u0437\u0430\u043A\u0446\u0438\u044F",
          date: "\u0414\u0430\u0442\u0430",
          type: "\u0422\u0438\u043F",
          change: "\u0418\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u0435",
          newPremiumPoints: "\u041D\u043E\u0432\u044B\u0435 \u043F\u0440\u0435\u043C\u0438\u0443\u043C-\u043E\u0447\u043A\u0438",
          close: "\u0417\u0430\u043A\u0440\u044B\u0442\u044C",
          filters: "\u0424\u0438\u043B\u044C\u0442\u0440\u044B",
          dateFrom: "\u0414\u0430\u0442\u0430 \u043D\u0430\u0447\u0430\u043B\u0430",
          dateTo: "\u0414\u0430\u0442\u0430 \u043E\u043A\u043E\u043D\u0447\u0430\u043D\u0438\u044F",
          worldFilter: "\u0424\u0438\u043B\u044C\u0442\u0440 \u043F\u043E \u043C\u0438\u0440\u0443",
          sortAsc: "\u0421\u043E\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u043F\u043E \u0432\u043E\u0437\u0440\u0430\u0441\u0442\u0430\u043D\u0438\u044E",
          sortDesc: "\u0421\u043E\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u043F\u043E \u0443\u0431\u044B\u0432\u0430\u043D\u0438\u044E",
          page: "\u0421\u0442\u0440\u0430\u043D\u0438\u0446\u0430",
          next: "\u0421\u043B\u0435\u0434\u0443\u044E\u0449\u0430\u044F",
          previous: "\u041F\u0440\u0435\u0434\u044B\u0434\u0443\u0449\u0430\u044F",
          chartTitle: "\u0418\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u044F \u0441 \u0442\u0435\u0447\u0435\u043D\u0438\u0435\u043C \u0432\u0440\u0435\u043C\u0435\u043D\u0438",
          expenses: "\u0420\u0430\u0441\u0445\u043E\u0434\u044B",
          sales: "\u041F\u0440\u0438\u0431\u044B\u043B\u044C",
          profit: "\u0414\u043E\u0445\u043E\u0434",
          aiPrompt: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0432\u0430\u0448 \u0432\u043E\u043F\u0440\u043E\u0441 \u0434\u043B\u044F \u0418\u0418-\u043F\u043E\u043C\u043E\u0449\u043D\u0438\u043A\u0430",
          aiLoading: "\u0417\u0430\u0433\u0440\u0443\u0437\u043A\u0430 \u043E\u0442\u0432\u0435\u0442\u0430...",
          aiError: "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u0438\u044F \u043E\u0442\u0432\u0435\u0442\u0430 \u043E\u0442 \u0418\u0418",
          minimize: "\u0421\u0432\u0435\u0440\u043D\u0443\u0442\u044C",
          stockDesiredTooltip: "Устанавливает максимальное количество {resource}, учитывая сумму ресурсов в деревне и находящихся в пути.",
          userRateTooltip: "\u041C\u0438\u043D\u0438\u043C\u0430\u043B\u044C\u043D\u0430\u044F \u0441\u0442\u0430\u0432\u043A\u0430 (\u043F\u0440\u0435\u043C\u0438\u0443\u043C-\u043E\u0447\u043A\u0438 \u0437\u0430 \u0435\u0434\u0438\u043D\u0438\u0446\u0443) \u0434\u043B\u044F \u043F\u043E\u043A\u0443\u043F\u043A\u0438 {resource}. \u0421\u043A\u0440\u0438\u043F\u0442 \u043F\u043E\u043A\u0443\u043F\u0430\u0435\u0442 \u0442\u043E\u043B\u044C\u043A\u043E \u0435\u0441\u043B\u0438 \u0440\u044B\u043D\u043E\u0447\u043D\u0430\u044F \u0441\u0442\u0430\u0432\u043A\u0430 \u0440\u0430\u0432\u043D\u0430 \u0438\u043B\u0438 \u0432\u044B\u0448\u0435.",
          buyPerTimeTooltip: "\u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u043E\u0435 \u043A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E {resource} \u0437\u0430 \u043F\u043E\u043A\u0443\u043F\u043A\u0443. \u0421\u043A\u0440\u0438\u043F\u0442 \u043D\u0435 \u043F\u0440\u0435\u0432\u044B\u0448\u0430\u0435\u0442 \u044D\u0442\u043E \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0437\u0430 \u0442\u0440\u0430\u043D\u0437\u0430\u043A\u0446\u0438\u044E.",
          reserveAmountTooltip: "\u041C\u0438\u043D\u0438\u043C\u0430\u043B\u044C\u043D\u043E\u0435 \u043A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E {resource} \u0434\u043B\u044F \u0445\u0440\u0430\u043D\u0435\u043D\u0438\u044F. \u0421\u043A\u0440\u0438\u043F\u0442 \u043D\u0435 \u043F\u0440\u043E\u0434\u0430\u0435\u0442, \u0435\u0441\u043B\u0438 \u0437\u0430\u043F\u0430\u0441 \u0440\u0430\u0432\u0435\u043D \u0438\u043B\u0438 \u043C\u0435\u043D\u044C\u0448\u0435.",
          reserveRateTooltip: "\u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u0430\u044F \u0441\u0442\u0430\u0432\u043A\u0430 (\u043F\u0440\u0435\u043C\u0438\u0443\u043C-\u043E\u0447\u043A\u0438 \u0437\u0430 \u0435\u0434\u0438\u043D\u0438\u0446\u0443) \u0434\u043B\u044F \u043F\u0440\u043E\u0434\u0430\u0436\u0438 {resource}. \u0421\u043A\u0440\u0438\u043F\u0442 \u043F\u0440\u043E\u0434\u0430\u0435\u0442 \u0442\u043E\u043B\u044C\u043A\u043E \u0435\u0441\u043B\u0438 \u0440\u044B\u043D\u043E\u0447\u043D\u0430\u044F \u0441\u0442\u0430\u0432\u043A\u0430 \u0440\u0430\u0432\u043D\u0430 \u0438\u043B\u0438 \u043D\u0438\u0436\u0435.",
          sellLimitTooltip: "\u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u043E\u0435 \u043A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E {resource} \u0437\u0430 \u043F\u0440\u043E\u0434\u0430\u0436\u0443. \u0421\u043A\u0440\u0438\u043F\u0442 \u043D\u0435 \u043F\u0440\u0435\u0432\u044B\u0448\u0430\u0435\u0442 \u044D\u0442\u043E \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0437\u0430 \u0442\u0440\u0430\u043D\u0437\u0430\u043A\u0446\u0438\u044E.",
          resourceNames: {
            wood: "\u0434\u0435\u0440\u0435\u0432\u043E",
            stone: "\u0433\u043B\u0438\u043D\u0430",
            iron: "\u0436\u0435\u043B\u0435\u0437\u043E"
          },

           // --- NOVAS Traduções para a Modal de Configurações (Russo) ---
          settingsSectionAccount: "\u0418\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u044F \u043E\u0431 \u0430\u043A\u043A\u0430\u0443\u043D\u0442\u0435", // Informações da Conta
          settingsSectionLanguage: "\u042F\u0437\u044B\u043A", // Idioma
          settingsSectionGeneral: "\u041E\u0431\u0449\u0438\u0435", // Geral
          settingsSectionSell: "\u041F\u0440\u043E\u0434\u0430\u0436\u0430", // Venda
          settingsLabelPlayer: "\u0418\u0433\u0440\u043E\u043A:", // Jogador:
          settingsLabelLicense: "\u041B\u0438\u0446\u0435\u043D\u0437\u0438\u044F \u0434\u0435\u0439\u0441\u0442\u0432\u0443\u0435\u0442 \u0434\u043E:", // Licença Expira em:
          settingsLabelVersion: "\u0412\u0435\u0440\u0441\u0438\u044F \u0441\u043A\u0440\u0438\u043F\u0442\u0430:", // Versão do Script:
          settingsLabelInterfaceLang: "\u042F\u0437\u044B\u043A \u0438\u043D\u0442\u0435\u0440\u0444\u0435\u0439\u0441\u0430:", // Idioma da Interface:
          settingsLabelCheckInterval: "\u0418\u043D\u0442\u0435\u0440\u0432\u0430\u043B \u043F\u0440\u043E\u0432\u0435\u0440\u043A\u0438 (\u0441\u0435\u043A):", // Intervalo Verificação (seg):
          settingsLabelAutoReload: "\u041F\u0435\u0440\u0435\u0437\u0430\u0433\u0440\u0443\u0437\u043A\u0430 \u043F\u0440\u0438 \u043E\u0448\u0438\u0431\u043A\u0435:", // Recarregar em erro:
          settingsLabelSellCooldown: "\u041F\u0430\u0443\u0437\u0430 \u043F\u0440\u043E\u0434\u0430\u0436\u0438 (\u0441\u0435\u043A):", // Cooldown Venda (seg):
          settingsLabelMerchantReserve: "\u0420\u0435\u0437\u0435\u0440\u0432 \u0442\u043E\u0440\u0433\u043E\u0432\u0446\u0435\u0432:", // Reserva de Mercadores:
          tooltipCheckInterval: "\u0427\u0430\u0441\u0442\u043E\u0442\u0430 (\u0432 \u0441\u0435\u043A\u0443\u043D\u0434\u0430\u0445), \u0441 \u043A\u043E\u0442\u043E\u0440\u043E\u0439 \u0441\u043A\u0440\u0438\u043F\u0442 \u043F\u0440\u043E\u0432\u0435\u0440\u044F\u0435\u0442 \u0440\u044B\u043D\u043E\u043A \u0438 \u0432\u044B\u043F\u043E\u043B\u043D\u044F\u0435\u0442 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044F.",
          tooltipAutoReload: "\u0415\u0441\u043B\u0438 \u043E\u0442\u043C\u0435\u0447\u0435\u043D\u043E, \u0441\u0442\u0440\u0430\u043D\u0438\u0446\u0430 \u0431\u0443\u0434\u0435\u0442 \u0430\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u0438 \u043F\u0435\u0440\u0435\u0437\u0430\u0433\u0440\u0443\u0436\u0435\u043D\u0430 \u043F\u0440\u0438 \u043E\u0448\u0438\u0431\u043A\u0435 \u043F\u043E\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0435\u043D\u0438\u044F \u0442\u0440\u0430\u043D\u0437\u0430\u043A\u0446\u0438\u0438.",
          tooltipSellCooldown: "\u041C\u0438\u043D\u0438\u043C\u0430\u043B\u044C\u043D\u043E\u0435 \u0432\u0440\u0435\u043C\u044F \u043E\u0436\u0438\u0434\u0430\u043D\u0438\u044F (\u0432 \u0441\u0435\u043A\u0443\u043D\u0434\u0430\u0445) \u043F\u043E\u0441\u043B\u0435 \u043F\u0440\u043E\u0434\u0430\u0436\u0438 \u043F\u0435\u0440\u0435\u0434 \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0439 \u043F\u043E\u043F\u044B\u0442\u043A\u043E\u0439.",
          tooltipMerchantReserve: "\u041A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E \u0442\u043E\u0440\u0433\u043E\u0432\u0446\u0435\u0432, \u043A\u043E\u0442\u043E\u0440\u044B\u0435 \u0441\u043A\u0440\u0438\u043F\u0442 \u0434\u043E\u043B\u0436\u0435\u043D \u0432\u0441\u0435\u0433\u0434\u0430 \u043E\u0441\u0442\u0430\u0432\u043B\u044F\u0442\u044C \u0441\u0432\u043E\u0431\u043E\u0434\u043D\u044B\u043C\u0438 \u0434\u043B\u044F \u0440\u0443\u0447\u043D\u043E\u0433\u043E \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u043D\u0438\u044F."
        }
      },
      en: {
        translation: {
          // --- Existing Translations (Kept) ---
          title: "RAGNAROK RESOURCE TRADING",
          buyModeToggleOn: "Turn Off Buying",
          buyModeToggleOff: "Turn On Buying",
          sellModeToggleOn: "Turn Off Selling",
          sellModeToggleOff: "Turn On Selling",
          saveConfig: "\u{1F4BE} Save",
          resetAll: "Reset Everything",
          pause: "Pause",
          transactions: "Transactions",
          aiAssistant: "Ragnarok AI Assistant",
          settings: "Settings",
          saveSuccess: "Settings saved successfully!",
          portuguese: "Portuguese",
          russian: "Russian",
          english: "English",
          activated: "Activated",
          deactivated: "Deactivated",
          transactionInProgress: "Processing transaction...",
          transactionSuccess: "Transaction completed successfully!",
          transactionError: "Transaction failed. Please try again.",
          domError: "Error accessing game elements. Refreshing...",
          noTransactions: "No transactions found.",
          transactionsHeader: "Transaction History",
          transaction: "Transaction",
          date: "Date",
          type: "Type",
          change: "Change",
          newPremiumPoints: "New Premium Points",
          close: "Close",
          filters: "Filters",
          dateFrom: "Start Date",
          dateTo: "End Date",
          worldFilter: "Filter by World",
          sortAsc: "Sort Ascending",
          sortDesc: "Sort Descending",
          page: "Page",
          next: "Next",
          previous: "Previous",
          chartTitle: "Changes Over Time",
          expenses: "Costs",
          sales: "Revenue",
          profit: "Profit",
          aiPrompt: "Type your question for the AI Assistant",
          aiLoading: "Loading response...",
          aiError: "Error retrieving AI response",
          minimize: "Minimise",
          stockDesiredTooltip: "Sets the maximum amount of {resource}, taking into account the sum of resources available in the village and those in transit.",
          userRateTooltip: "Minimum rate (premium points per unit) to buy {resource}. The script only buys if the market rate is at or above this.",
          buyPerTimeTooltip: "Maximum amount of {resource} per purchase. The script won't exceed this per transaction.",
          reserveAmountTooltip: "Minimum amount of {resource} to keep. The script won't sell if stock is at or below this.",
          reserveRateTooltip: "Maximum rate (premium points per unit) to sell {resource}. The script only sells if the market rate is at or below this.",
          sellLimitTooltip: "Maximum amount of {resource} per sale. The script won't exceed this per transaction.",
          resourceNames: {
            wood: "wood",
            stone: "clay",
            iron: "iron"
          },

          // --- NEW Translations for Settings Modal (English) ---
          settingsSectionAccount: "Account Information",
          settingsSectionLanguage: "Language",
          settingsSectionGeneral: "General",
          settingsSectionSell: "Selling",
          settingsLabelPlayer: "Player:",
          settingsLabelLicense: "License Expires:",
          settingsLabelVersion: "Script Version:",
          settingsLabelInterfaceLang: "Interface Language:",
          settingsLabelCheckInterval: "Check Interval (sec):",
          settingsLabelAutoReload: "Reload on Error:",
          settingsLabelSellCooldown: "Sell Cooldown (sec):",
          settingsLabelMerchantReserve: "Merchant Reserve:",
          tooltipCheckInterval: "Frequency (in seconds) the script checks the market and performs actions.",
          tooltipAutoReload: "If checked, the page will automatically reload if an error occurs confirming a transaction.",
          tooltipSellCooldown: "Minimum waiting time (in seconds) after a sale before attempting to sell again.",
          tooltipMerchantReserve: "Number of merchants the script should always leave free for manual use."
        }
      }
    }
  };

  // Re-initialize i18next with the updated translations
  const i18n = window.i18next;
  i18n.init({
    lng: localStorage.getItem("language") || "pt", // Keep using saved language or default
    fallbackLng: "en",
    resources: translations.resources, // Use the updated resources object
    debug: false // Set to true for i18next debugging if needed
  });
  const elementCache = /* @__PURE__ */ new Map();
  let currentResources = { wood: 0, stone: 0, iron: 0 };
  const resourceImgSrc = {
    wood: "wood",
    stone: "clay",
    iron: "iron"
  };
  function getResourceAmount(doc, resourceName) {
    let selector = `#${resourceName}.res`;
    if (resourceName === "stone") {
      selector = "#stone";
    }
    const resourceElement = doc.querySelector(selector);
    if (resourceElement) {
      const textContent = resourceElement.textContent;
      const trimmedText = textContent.trim();
      const parsedValue = _.parseInt(trimmedText.replace(/\D/g, ""), 10);
      return parsedValue || 0;
    } else {
      return 0;
    }
  }
  function getStorageCapacity() {
    if (typeof TribalWars !== "undefined" && TribalWars.getGameData) {
      const villageData = TribalWars.getGameData().village;
      const storageCapacity = villageData.storage_max || 1e3;
      return storageCapacity;
    }
    const storageElement = document.querySelector("#storage");
    if (!storageElement) return 1e3;
    const storageText = storageElement.textContent.trim();
    const parts = storageText.split("/");
    if (parts.length >= 2) {
      const maxStorage = sanitizeNumber(parts[1]);
      return maxStorage;
    }
    return 1e3;
  }
  async function fetchResources() {
    const villageId = TribalWars.getGameData().village.id;
    const overviewUrl = `https://${window.location.host}/game.php?village=${villageId}&screen=overview`;
    const response = await fetchMarketData(overviewUrl);
    if (response) {
      const html = response;
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, "text/html");
      currentResources.wood = getResourceAmount(doc, "wood");
      currentResources.stone = getResourceAmount(doc, "stone");
      currentResources.iron = getResourceAmount(doc, "iron");
    }
    state.storageCapacity = getStorageCapacity();
  }
  class ResourceHandler {
    constructor(name, config) {
      this.name = name;
      this.config = config;
      this.elementCache = /* @__PURE__ */ new Map();
    }
    getDomElement(selector) {
      if (!this.elementCache.has(selector)) {
        const element = document.querySelector(selector);
        this.elementCache.set(selector, element);
        return element;
      }
      return this.elementCache.get(selector);
    }
    sanitizeNumber(value) {
      return _.parseInt(value, 10) || 0;
    }
    getStock() {
      return this.sanitizeNumber(this.getDomElement(this.config.stockSelector)?.textContent.trim());
    }
    getGameRate() {
      return this.sanitizeNumber(this.getDomElement(this.config.rateSelector)?.textContent.trim().replace(/\D/g, ""));
    }
    getUserRate() {
      return this.sanitizeNumber(this.config.uiRateInput?.value);
    }
    getTotal() {
      return currentResources[this.name];
    }
    getReserved() {
      return this.sanitizeNumber(this.config.uiReserveInput?.value);
    }
    getMarketValue() {
      const marketImg = this.getDomElement(this.config.marketImg);
      if (!marketImg) {
        return 0;
      }
      const valueText = marketImg.parentElement?.textContent.trim();
      if (!valueText) {
        return 0;
      }
      return this.sanitizeNumber(valueText.replace(/[^0-9]/g, "")) || 0;
    }
    getReserveRate() {
      return this.sanitizeNumber(this.config.uiReserveRateInput?.value);
    }
    getBuyInput() {
      return this.getDomElement(this.config.buyInputSelector);
    }
    getSellInput() {
      return this.getDomElement(this.config.sellInputSelector);
    }
  }
  const resourceTemplate = (name, outputDefault) => ({
    stockSelector: `#premium_exchange_stock_${name}`,
    rateSelector: `#premium_exchange_rate_${name} > div:nth-child(1)`,
    buyInputSelector: `input.premium-exchange-input[data-resource="${name}"][data-type="buy"]`,
    sellInputSelector: `input.premium-exchange-input[data-resource="${name}"][data-type="sell"]`,
    totalSelector: `#${name}.res`,
    marketImg: `.premium-exchange-sep ${`img[src*="${name}_18x16"]`}`,
    outputDefault
  });
  const resourceConfigs = {
    wood: resourceTemplate("wood", 39),
    stone: resourceTemplate("stone", 46),
    iron: resourceTemplate("iron", 63)
  };
  const state = mobx.observable({
    resources: {
      storageCapacity: 1e3,
      wood: 0,
      stone: 0,
      iron: 0
    },
    incomingResources: {
      wood: 0,
      stone: 0,
      iron: 0
    },
    marketRates: {},
    transactions: [],
    buyModeActive: localStorage.getItem("buyModeActive") === "true",
    sellModeActive: localStorage.getItem("sellModeActive") === "true",
    hasExecutedBuy: false,
    hasExecutedSell: false,
    reloadPending: false,
    isDarkMode: window.matchMedia("(prefers-color-scheme: dark)").matches,
    currentVillage: null,
    worldProfit: 0,
    language: localStorage.getItem("language") || "pt",
    optimizedRates: mobx.computed(function() {
      return this.marketRates;
    }),
    rateHistory: {
      wood: [],
      stone: [],
      iron: []
    },
    marketTrends: {
      wood: "neutral",
      stone: "neutral",
      iron: "neutral"
    },
    marketVolatility: {
      wood: 0,
      stone: 0,
      iron: 0
    },
    lastUpdate: {
      wood: null,
      stone: null,
      iron: null
    },
    marketConditions: mobx.computed(function() {
      return {
        wood: {
          trend: this.marketTrends.wood,
          volatility: this.marketVolatility.wood,
          lastUpdate: this.lastUpdate.wood
        },
        stone: {
          trend: this.marketTrends.stone,
          volatility: this.marketVolatility.stone,
          lastUpdate: this.lastUpdate.stone
        },
        iron: {
          trend: this.marketTrends.iron,
          volatility: this.marketVolatility.iron,
          lastUpdate: this.lastUpdate.iron
        }
      };
    }),
    isUpdating: false,
    isSettingsModalOpen: false
  });
  const ui = {
    elements: /* @__PURE__ */ new Map(),
    buyInputs: /* @__PURE__ */ new Map(),
    sellInputs: /* @__PURE__ */ new Map(),
    gameElements: /* @__PURE__ */ new Map(),
    getElement(key) {
      if (!this.elements.has(key)) {
        const element = elementCache.get(key) || document.querySelector(`#${key}`);
        if (element) {
          this.elements.set(key, element);
          elementCache.set(key, element);
        }
        return element;
      }
      return this.elements.get(key);
    }
  };
  const createElement = (tag, props = {}) => {
    const element = Object.assign(document.createElement(tag), props);
    if (props.id) elementCache.set(props.id, element);
    return element;
  };
  const tooltip = createElement("div", { className: "tooltip", style: "display: none;" });
  document.body.appendChild(tooltip);
  const hideTooltip = () => {
    tooltip.style.display = "none";
    if (tooltip.parentNode !== document.body) {
      document.body.appendChild(tooltip);
    }
  };
  function isModalOpen() {
    const transactionsModal = document.getElementById("transactionsModal");
    const aiModal = document.getElementById("aiModal");
    const settingsModal = document.getElementById("settingsModal");
    return transactionsModal && transactionsModal.style.display === "flex" || aiModal && aiModal.style.display === "flex" || settingsModal && settingsModal.style.display === "flex";
  }
  const showTooltip = (event, text) => {
    if (!text) return;
    const resourceKey = event.target.dataset.resource.split("-")[0];
    const translatedResource = i18n.t(`resourceNames.${resourceKey}`);
    const finalText = i18n.t(event.target.dataset.tooltip, { resource: translatedResource });
    tooltip.innerHTML = finalText;
    document.body.appendChild(tooltip);
    const inputElement = event.target;
    const inputRect = inputElement.getBoundingClientRect();
    const tooltipWidth = tooltip.offsetWidth;
    const tooltipHeight = tooltip.offsetHeight;
    let x = inputRect.left + window.scrollX + 5;
    let y = inputRect.bottom + window.scrollY + 5;
    if (x + tooltipWidth > window.innerWidth) {
      x = window.innerWidth - tooltipWidth - 10;
    }
    if (y + tooltipHeight > window.innerHeight) {
      y = inputRect.top + window.scrollY - tooltipHeight - 5;
    }
    tooltip.style.left = `${x}px`;
    tooltip.style.top = `${y}px`;
    tooltip.style.display = "block";
  };
  const updateTooltipPosition = (event) => {
    if (!tooltip.style.display || tooltip.style.display === "none") return;
    const inputElement = event.target;
    const inputRect = inputElement.getBoundingClientRect();
    const tooltipWidth = tooltip.offsetWidth;
    const tooltipHeight = tooltip.offsetHeight;
    let x = inputRect.left + window.scrollX + 5;
    let y = inputRect.bottom + window.scrollY + 5;
    if (x + tooltipWidth > window.innerWidth) {
      x = window.innerWidth - tooltipWidth - 10;
    }
    if (y + tooltipHeight > window.innerHeight) {
      y = inputRect.top + window.scrollY - tooltipHeight - 5;
    }
    tooltip.style.left = `${x}px`;
    tooltip.style.top = `${y}px`;
  };
  const sanitizeNumber = (value) => _.parseInt(value, 10) || 0;
  const createResourceCard = (resource, type, iconUrl, placeholders) => {
    const tooltipKeys = {
      "wood-stock": "stockDesiredTooltip",
      "stone-stock": "stockDesiredTooltip",
      "iron-stock": "stockDesiredTooltip",
      "wood": "userRateTooltip",
      "stone": "userRateTooltip",
      "iron": "userRateTooltip",
      "buy-per-time": "buyPerTimeTooltip",
      "storage-limit": "buyPerTimeTooltip",
      "max-spend": "buyPerTimeTooltip",
      "reserve-wood": "reserveAmountTooltip",
      "reserve-stone": "reserveAmountTooltip",
      "reserve-iron": "reserveAmountTooltip",
      "reserve-wood-rate": "reserveRateTooltip",
      "reserve-stone-rate": "reserveRateTooltip",
      "reserve-iron-rate": "reserveRateTooltip",
      "sell-limit": "sellLimitTooltip",
      "sell-limit-stone": "sellLimitTooltip",
      "sell-limit-iron": "sellLimitTooltip"
    };
    const getTooltipKey = (resourceName, placeholderKey) => {
      if (type === "buy") {
        if (placeholderKey === 0) return tooltipKeys[`${resourceName}-stock`];
        if (placeholderKey === 1) return tooltipKeys[resourceName];
        if (placeholderKey === 2 && placeholders[2].key === "buy-per-time") return tooltipKeys["buy-per-time"];
        if (placeholderKey === 2 && placeholders[2].key === "storage-limit") return tooltipKeys["storage-limit"];
        if (placeholderKey === 2 && placeholders[2].key === "max-spend") return tooltipKeys["max-spend"];
      } else if (type === "sell") {
        if (placeholderKey === 0) return tooltipKeys[`reserve-${resourceName}`];
        if (placeholderKey === 1) return tooltipKeys[`reserve-${resourceName}-rate`];
        if (placeholderKey === 2 && placeholders[2].key === "sell-limit") return tooltipKeys["sell-limit"];
        if (placeholderKey === 2 && placeholders[2].key === "sell-limit-stone") return tooltipKeys["sell-limit-stone"];
        if (placeholderKey === 2 && placeholders[2].key === "sell-limit-iron") return tooltipKeys["sell-limit-iron"];
      }
      return void 0;
    };
    return `
    <div class="resource-card base-card" data-resource="${resource}">
        <img src="${iconUrl}" alt="${resource}" />
        <input type="number" class="rate-input"
               data-resource="${type === "buy" ? `${resource}-stock` : `reserve-${resource}`}"
               data-tooltip="${getTooltipKey(resource, 0)}"
               placeholder="${placeholders[0]}">

        <span>${type === "buy" ? "\u2191" : "\u2193"}</span>

        <input type="number" class="rate-input"
               data-resource="${type === "buy" ? resource : `reserve-${resource}-rate`}"
               data-tooltip="${getTooltipKey(resource, 1)}"
               placeholder="${placeholders[1]}">

        <div class="num-input">
            <img src="https://dsus.innogamescdn.com/asset/95eda994/graphic/items/resources.png" alt="Resources" class="resource-icon" />
            <input type="number" class="rate-input"
                   data-resource="${type === "buy" ? placeholders[2].key : `sell-limit${resource === "wood" ? "" : `-${resource}`}`}"
                   data-tooltip="${getTooltipKey(resource, 2)}"
                   placeholder="${placeholders[2].value}">
        </div>
    </div>
  `;
  };
  const createButton = (id, text, classes = "black-btn") => `<button class="${classes}" id="${id}">${text}</button>`;
  const callGeminiAPI = async (prompt) => {
    try {
      const response = await axios.post(
        `${GEMINI_API_URL}?key=${GEMINI_API_KEY}`,
        {
          contents: [{
            parts: [{
              text: prompt
            }]
          }]
        },
        {
          headers: {
            "Content-Type": "application/json"
          },
          timeout: 1e4
        }
      );
      if (response.status === 200) {
        const content = response.data.candidates?.[0]?.content?.parts?.[0]?.text || "No response";
        return content;
      } else {
        throw new Error(`HTTP error! status: ${response.status}, ${response.statusText}`);
      }
    } catch (error) {
      throw error;
    }
  };
  const initializeUI = () => {
    const container = createElement("div", {
      className: "market-container draggable",
      style: "position: fixed; top: 50px; left: 50px; z-index: 2147483647;"
    });
    elementCache.set("market-container", container);
    container.innerHTML = `
  <div class="market-container">
       <div class="header">
      <h2 id="headerTitle">${i18n.t("title")}</h2>
      <div class="dropdowns">
          <div class="dropdown">
              <span class="village-icon">
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5S10.62 6.5 12 6.5s2.5 1.12 2.5 2.5S13.38 11.5 12 11.5z" fill="#ffa500"/>
</svg>
</span>
              <select id="villageSelect"><option value="current">Carregando...</option></select>
          </div>
          <div class="profit-info">
              <span class="icon header premium"></span> <span id="worldProfit">0</span>
          </div>
      </div>
      <div class="header-buttons">
  <div class="btn-group-left">
 <button class="icon-btn" id="aiAssistantBtn">
  <i class="fa-solid fa-robot"></i>
</button>
</div>
  <div class="btn-group-right">
      ${createButton("minimizeButton", `<i class="fa-solid fa-window-minimize"></i>`, "icon-btn")}
      ${createButton("settingsBtn", `<i class="fa-solid fa-gear"></i>`, "icon-btn")}
  </div>
</div>
      <div class="sections">
          <div class="section buy" id="buySection">
              <h3>Status: <span class="status" id="buyStatus">${i18n.t(state.buyModeActive ? "activated" : "deactivated")}</span></h3>
              <div class="sortable-container" id="buySortable">
                  ${createResourceCard("wood", "buy", "https://dsus.innogamescdn.com/asset/95eda994/graphic/premium/features/WoodProduction_large.png", ["200", "2000", { key: "buy-per-time", value: "5000" }])}
                  ${createResourceCard("stone", "buy", "https://dsus.innogamescdn.com/asset/95eda994/graphic/premium/features/StoneProduction_large.png", ["200", "2000", { key: "storage-limit", value: "5000" }])}
                  ${createResourceCard("iron", "buy", "https://dsus.innogamescdn.com/asset/95eda994/graphic/premium/features/IronProduction_large.png", ["200", "2000", { key: "max-spend", value: "5000" }])}
              </div>
              <div class="buttons">
                  ${createButton("buyModeToggle", i18n.t(state.buyModeActive ? "buyModeToggleOn" : "buyModeToggleOff"), "black-btn toggle-btn")}
                  <div class="premium-input-wrapper">
                      <span class="icon header premium"></span>
                      <input type="number" id="premiumPointsInput" placeholder="PP">
                  </div>
                  ${createButton("buyPause", i18n.t("pause"))}
                  <span class="spinner" id="buySpinner" style="display: none;"></span>
              </div>
          </div>
          <div class="section sell" id="sellSection">
              <h3>Status: <span class="status" id="sellStatus">${i18n.t(state.sellModeActive ? "activated" : "deactivated")}</span></h3>
              <div class="sortable-container" id="sellSortable">
                  ${createResourceCard("wood", "sell", "https://dsus.innogamescdn.com/asset/95eda994/graphic/premium/features/WoodProduction_large.png", ["1000", "64", { key: "sell-limit", value: "200" }])}
                  ${createResourceCard("stone", "sell", "https://dsus.innogamescdn.com/asset/95eda994/graphic/premium/features/StoneProduction_large.png", ["1000", "64", { key: "sell-limit-stone", value: "200" }])}
                  ${createResourceCard("iron", "sell", "https://dsus.innogamescdn.com/asset/95eda994/graphic/premium/features/IronProduction_large.png", ["1000", "64", { key: "sell-limit-iron", value: "200" }])}
              </div>
              <div class="buttons">
                  ${createButton("sellModeToggle", i18n.t(state.sellModeActive ? "sellModeToggleOn" : "sellModeToggleOff"), "black-btn toggle-btn")}
                  ${createButton("sellPause", i18n.t("pause"))}
                  <span class="spinner" id="sellSpinner" style="display: none;"></span>
              </div>
          </div>
      </div>
      <div class="footer">
          <div class="footer-buttons-row">
              ${createButton("resetAll", `\u21BB ${i18n.t("resetAll")}`)}
              ${createButton("transactionsBtn", i18n.t("transactions"))}
              ${createButton("saveConfig", i18n.t("saveConfig"))}
          </div>
      </div>
      <div class="notification" id="notification" style="display: none;"></div>
      <div class="modal" id="transactionsModal" style="display: none;">
          <div class="modal-content">
              <h3>${i18n.t("transactionsHeader")}</h3>
              <div id="filterSection"></div>
              <div id="transactionsTableContainer"></div>
              <div id="paginationControls" style="margin-top: 10px;"></div>
              <canvas id="transactionsChart" style="display: block; margin-top: 20px; max-width: 100%;"></canvas>
              <div style="margin-top: 10px;">
                  ${createButton("closeModal", i18n.t("close"))}
              </div>
          </div>
      </div>
      <div class="modal" id="aiModal" style="display: none;">
          <div class="modal-content">
              <h3>${i18n.t("aiAssistant")}</h3>
              <textarea id="aiPrompt" placeholder="${i18n.t("aiPrompt")}" rows="4" style="width: 100%; margin-bottom: 10px;"></textarea>
              <div id="aiResponse" style="margin-bottom: 10px;"></div>
              <div>
                  ${createButton("submitAI", "Enviar")}
                  ${createButton("closeAIModal", i18n.t("close"))}
              </div>
          </div>
      </div>



            <!-- Modal de Configurações com data-i18n-key -->
      <div class="modal" id="settingsModal" style="display: none;">
          <div class="modal-content settings-content">
              <div class="settings-header">
                  <h3 data-i18n-key="settings">${i18n.t("settings")}</h3>
                  <button id="closeSettingsModal" class="close-btn" data-i18n-key-title="close" title="${i18n.t("close")}">×</button>
              </div>

              <div class="settings-body">
                  <div class="settings-section user-info-section">
                      <h4 data-i18n-key="settingsSectionAccount">${i18n.t("settingsSectionAccount")}</h4>
                      <div class="info-row">
                          <span class="info-label" data-i18n-key="settingsLabelPlayer"><i class="fas fa-user"></i> ${i18n.t("settingsLabelPlayer")}</span>
                          <span class="info-value" id="settingsPlayerName">Carregando...</span>
                      </div>
                      <div class="info-row">
                          <span class="info-label" data-i18n-key="settingsLabelLicense"><i class="fas fa-calendar-alt"></i> ${i18n.t("settingsLabelLicense")}</span>
                          <span class="info-value" id="settingsLicenseExpiry">Carregando...</span>
                      </div>
                      <div class="info-row">
                          <span class="info-label" data-i18n-key="settingsLabelVersion"><i class="fas fa-code-branch"></i> ${i18n.t("settingsLabelVersion")}</span>
                          <span class="info-value" id="settingsScriptVersion">Carregando...</span>
                      </div>
                  </div>

                  <div class="settings-section language-settings">
                      <h4 data-i18n-key="settingsSectionLanguage">${i18n.t("settingsSectionLanguage")}</h4>
                      <div class="setting-item">
                           <label for="languageSelect" data-i18n-key="settingsLabelInterfaceLang"><i class="fas fa-language"></i> ${i18n.t("settingsLabelInterfaceLang")}</label>
                           <select id="languageSelect">
                                <!-- As opções são geradas dinamicamente em updateUI -->
                           </select>
                      </div>
                  </div>

                   <div class="settings-section general-settings">
                       <h4 data-i18n-key="settingsSectionGeneral">${i18n.t("settingsSectionGeneral")}</h4>
                       <div class="setting-item">
                           <label for="checkIntervalInput" data-i18n-key="settingsLabelCheckInterval"><i class="fas fa-sync-alt"></i> ${i18n.t("settingsLabelCheckInterval")}</label>
                           <input type="number" class="settings-input" id="checkIntervalInput" min="5" step="1" placeholder="30">
                       </div>
                        <div class="setting-item checkbox-item">
                          <input type="checkbox" class="settings-checkbox" id="autoReloadOnErrorInput" checked>
                          <label for="autoReloadOnErrorInput" data-i18n-key="settingsLabelAutoReload"><i class="fas fa-redo"></i> ${i18n.t("settingsLabelAutoReload")}</label>
                       </div>
                   </div>

                   <div class="settings-section sell-settings">
                       <h4 data-i18n-key="settingsSectionSell">${i18n.t("settingsSectionSell")}</h4>
                        <div class="setting-item">
                           <label for="sellCooldownInput" data-i18n-key="settingsLabelSellCooldown"><i class="fas fa-stopwatch"></i> ${i18n.t("settingsLabelSellCooldown")}</label>
                           <input type="number" class="settings-input" id="sellCooldownInput" min="1" step="1" placeholder="6">
                        </div>
                        <div class="setting-item">
                           <label for="merchantReserveInput" data-i18n-key="settingsLabelMerchantReserve"><i class="fas fa-truck"></i> ${i18n.t("settingsLabelMerchantReserve")}</label>
                           <input type="number" class="settings-input" id="merchantReserveInput" min="0" step="1" placeholder="0">
                        </div>
                   </div>
              </div>

              <div class="settings-footer">
                   <!-- Botão Salvar (se necessário) pode ser adicionado aqui -->
              </div>
          </div>
      </div>
`;
    document.body.appendChild(container);
    const minimizedBox = createElement("div", {
      id: "minimizedMarketBox",
      className: "minimized-box",
      style: `
      position: fixed;
      right: 10px;
      top: 10px;
      width: 40px;
      height: 40px;
      background-color: #2a2d32;
      border: 2px solid #ffd700;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
      color: #ffffff;
      font-family: 'Roboto', sans-serif;
      font-size: 20px;
      font-weight: 700;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 8px;
      cursor: pointer;
      z-index: 2147483647;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
  `
    });
    document.body.appendChild(minimizedBox);
    const fetchPlayerInitial = () => {
      if (typeof TribalWars === "undefined" || !TribalWars.getGameData) return "?";
      const player = TribalWars.getGameData().player;
      return player?.name?.charAt(0).toUpperCase() || "?";
    };
    const updateMinimizedBox = () => {
      const initial = fetchPlayerInitial();
      minimizedBox.textContent = initial;
      const colors = ["#FF5733", "#33FF57", "#3357FF", "#F3FF33", "#FF33F3"];
      const colorIndex = initial.charCodeAt(0) % colors.length;
      minimizedBox.style.backgroundColor = "#b8860b";
      minimizedBox.style.color = "#000000";
    };
    updateMinimizedBox();
    setInterval(updateMinimizedBox, 6e4);
    minimizedBox.addEventListener("mouseenter", () => {
      minimizedBox.style.transform = "scale(1.1)";
      minimizedBox.style.boxShadow = "0 6px 20px rgba(255, 215, 0, 0.8)";
    });
    minimizedBox.addEventListener("mouseleave", () => {
      minimizedBox.style.transform = "scale(1)";
      minimizedBox.style.boxShadow = "0 4px 15px rgba(0, 0, 0, 0.5)";
    });
    const isMinimized = localStorage.getItem("isMinimized") === "true";
    state.isMinimized = isMinimized;
    minimizeButton.addEventListener("click", () => {
      state.isMinimized = true;
      container.style.display = "none";
      minimizedBox.style.display = "block";
      localStorage.setItem("isMinimized", "true");
    });
    minimizedBox.addEventListener("click", () => {
      state.isMinimized = false;
      container.style.display = "block";
      minimizedBox.style.display = "none";
      localStorage.setItem("isMinimized", "false");
    });
    addDragAndDropListeners(container);
    initializeSortable();
    const savedPos = JSON.parse(localStorage.getItem("marketContainerPosition"));
    if (savedPos) {
      container.style.left = savedPos.left;
      container.style.top = savedPos.top;
    }
  };
  const addDragAndDropListeners = (element) => {
    let isDragging = false;
    let offsetX, offsetY;
    let animationFrame = null;
    let lastX, lastY;
    let isProcessing = false;
    element.addEventListener("mousedown", (e) => {
      isDragging = true;
      const rect = element.getBoundingClientRect();
      offsetX = e.clientX - rect.left;
      offsetY = e.clientY - rect.top;
      element.style.cursor = "grabbing";
    });
    document.addEventListener("mouseup", () => {
      if (isDragging) {
        isDragging = false;
        element.style.cursor = "move";
        cancelAnimationFrame(animationFrame);
        if (element.style.left && element.style.top) {
          localStorage.setItem(
            "marketContainerPosition",
            JSON.stringify({
              left: element.style.left,
              top: element.style.top
            })
          );
        }
      }
    });
    document.addEventListener("mousemove", (e) => {
      if (!isDragging || isProcessing) return;
      isProcessing = true;
      let newX = e.clientX - offsetX;
      let newY = e.clientY - offsetY;
      const maxX = window.innerWidth - element.offsetWidth - 10;
      const maxY = window.innerHeight - element.offsetHeight - 10;
      lastX = Math.max(0, Math.min(newX, maxX));
      lastY = Math.max(0, Math.min(newY, maxY));
      const moveElement = () => {
        animationFrame = requestAnimationFrame(() => {
          if (isDragging) {
            element.style.left = `${lastX}px`;
            element.style.top = `${lastY}px`;
            moveElement();
          }
        });
      };
      moveElement();
      e.preventDefault();
      setTimeout(() => isProcessing = false, 16);
    });
    element.addEventListener("mouseleave", () => {
      if (isDragging) {
        isDragging = false;
        element.style.cursor = "move";
        cancelAnimationFrame(animationFrame);
      }
    });
  };
  const initializeSortable = () => {
    if (typeof Sortable === "undefined") {
      return;
    }
    const buySortable = document.getElementById("buySortable");
    const sellSortable = document.getElementById("sellSortable");
    new Sortable(buySortable, {
      animation: 150,
      handle: ".resource-card",
      onEnd: (evt) => {
      }
    });
    new Sortable(sellSortable, {
      animation: 150,
      handle: ".resource-card",
      onEnd: (evt) => {
      }
    });
  };
  const getActiveWorld = () => {
    return window.location.hostname.split(".")[0];
  };
  const updateVillageInfo = () => {
    if (typeof TribalWars !== "undefined" && TribalWars.getGameData) {
      const villageData = TribalWars.getGameData().village;
      if (villageData) {
        state.currentVillage = {
          name: villageData.name,
          coordinates: villageData.coord,
          world: getActiveWorld()
        };
        ui.getElement("villageSelect").innerHTML = `<option value="current">${villageData.name} (${villageData.coord})</option>`;
        return;
      }
    }
    state.currentVillage = { name: "Desconhecido", coordinates: "N/A", world: getActiveWorld() };
    ui.getElement("villageSelect").innerHTML = `<option value="current">Carregando...</option>`;
  };
  const initializeElements = () => {
    const elementsToCache = [
      "headerTitle",
      "worldProfit",
      "buyModeToggle",
      "sellModeToggle",
      "saveConfig",
      "resetAll",
      "transactionsBtn",
      "aiAssistantBtn",
      "settingsBtn",
      "languageSelect",
      "villageSelect",
      "buyStatus",
      "sellStatus",
      "buyPause",
      "sellPause",
      "buySpinner",
      "sellSpinner",
      "notification",
      "transactionsModal",
      "transactionsTableContainer",
      "filterSection",
      "paginationControls",
      "transactionsChart",
      "closeModal",
      "aiModal",
      "aiPrompt",
      "aiResponse",
      "submitAI",
      "closeAIModal",
      "minimizeButton",
      "minimizedMarketBox",
      "settingsModal",
      "closeSettingsModal",
      "premiumPointsInput"
    ];
    elementsToCache.forEach((id) => {
      const element = document.querySelector(`#${id}`);
      if (element) {
        ui.elements.set(id, element);
        elementCache.set(id, element);
      }
    });
    ui.elements.set("inputs", Array.from(document.querySelectorAll(".rate-input")));
    ui.elements.set("buyPerTimeInput", document.querySelector('.rate-input[data-resource="buy-per-time"]'));
    ui.elements.set("storageLimitInput", document.querySelector('.rate-input[data-resource="storage-limit"]'));
    ui.elements.set("maxSpendInput", document.querySelector('.rate-input[data-resource="max-spend"]'));
    ui.elements.set("sellLimitInput", document.querySelector('.rate-input[data-resource="sell-limit"]'));
    return Array.from(ui.elements.values()).every((el) => el !== null);
  };
  const initializeResources = () => {
    const resources2 = Object.keys(resourceConfigs).reduce((acc, name) => {
      const config = { ...resourceConfigs[name] };
      config.uiRateInput = document.querySelector(`.rate-input[data-resource="${name}"]`);
      config.uiReserveInput = document.querySelector(`.rate-input[data-resource="reserve-${name}"]`);
      config.uiReserveRateInput = document.querySelector(`.rate-input[data-resource="reserve-${name}-rate"]`);
      acc[name] = new ResourceHandler(name, config);
      return acc;
    }, {});
    Object.keys(resources2).forEach((name) => {
      ui.buyInputs.set(name, resources2[name].getBuyInput());
      ui.sellInputs.set(name, resources2[name].getSellInput());
      const buyInput = ui.buyInputs.get(name);
      if (buyInput && !buyInput.dataset.default) {
        buyInput.dataset.default = "1000";
      }
    });
    return resources2;
  };
  const updateGameElements = () => {
    ui.gameElements.set("merchants", document.querySelector("#market_merchant_available_count"));
    ui.gameElements.set("merchants", document.querySelector("#market_merchant_available_count"));
    ui.gameElements.set("calculateButton", document.querySelector("input.btn-premium-exchange-buy"));
    ui.gameElements.set("sellButton", document.querySelector("#premium_exchange_form > input"));
  };
  const scheduleReload = () => {
    if (!state.reloadPending) {
      state.reloadPending = true;
      setTimeout(() => {
        window.location.reload();
        state.reloadPending = false;
      }, 2e3);
    }
  };
  const notifyUser = (message, type = "success", duration = 3e3) => {
    const notification = ui.getElement("notification");
    notification.textContent = message;
    notification.className = `notification ${type}`;
    notification.style.display = "block";
    notification.style.opacity = "1";
    setTimeout(() => {
      notification.style.opacity = "0";
      setTimeout(() => notification.style.display = "none", 500);
    }, duration);
  };
  const notifySuccess = (message) => notifyUser(message, "success");
  const notifyError = (message) => notifyUser(message, "error");
  const updateTheme = () => {
    state.isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches;
    const container = elementCache.get("market-container");
    container.classList.toggle("dark", state.isDarkMode);
    container.classList.toggle("light", !state.isDarkMode);
  };
  window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", updateTheme);
  const toggleMode = (mode) => {
    state[mode] = !state[mode];
    localStorage.setItem(mode, state[mode]);
    state.hasExecutedBuy = mode === "buyModeActive" && !state[mode] ? false : state.hasExecutedBuy;
    state.hasExecutedSell = mode === "sellModeActive" && !state[mode] ? false : state.hasExecutedSell;
    updateUI();
    if (state[mode]) mode === "buyModeActive" ? updateAll() : updateSell();
    else if (mode === "buyModeActive") resetBuyInputs();
  };
  let isFetching = false;
  let cachedTransactions = null;
  const checkForUpdates = async () => {
    try {
      const { transactions: firstPageTransactions } = await fetchPage(1);
      if (firstPageTransactions.length === 0) {
        return false;
      }
      const latestServerDate = firstPageTransactions[0].date;
      if (!cachedTransactions || cachedTransactions.length === 0) {
        return false;
      }
      const latestSavedDate = cachedTransactions[0].date;
      return latestServerDate > latestSavedDate;
    } catch (error) {
      return true;
    }
  };
  const fetchAllPages = async () => {
    let allTransactions = [];
    let pageNum = 1;
    let totalPages = null;
    try {
      const { transactions, doc } = await fetchPage(pageNum);
      allTransactions.push(...transactions);
      const paginationLinks = doc.querySelectorAll("a[href*='page=']");
      let maxPage = 1;
      paginationLinks.forEach((link) => {
        const href = link.getAttribute("href");
        const pageMatch = href.match(/page=(\d+)/);
        if (pageMatch) {
          const pageNum2 = _.parseInt(pageMatch[1]) + 1;
          maxPage = Math.max(maxPage, pageNum2);
        }
      });
      totalPages = maxPage;
    } catch (error) {
      isFetching = false;
      throw error;
    }
    while (pageNum < totalPages) {
      pageNum++;
      try {
        const { transactions } = await fetchPage(pageNum);
        allTransactions.push(...transactions);
        if (transactions.length === 0) {
          break;
        }
      } catch (error) {
        break;
      }
      await new Promise((resolve) => setTimeout(resolve, 200));
    }
    allTransactions.sort((a, b) => b.date - a.date);
    localStorage.setItem("ragnarokMarketTransactions", JSON.stringify(allTransactions));
    cachedTransactions = allTransactions;
    isFetching = false;
    return allTransactions;
  };
  const fetchPremiumLogs = () => {
    return new Promise(async (resolve, reject) => {
      if (isFetching) {
        if (cachedTransactions) {
          return resolve(cachedTransactions);
        }
        return reject("Busca em andamento. Tente novamente em breve.");
      }
      isFetching = true;
      const savedTransactions = localStorage.getItem("ragnarokMarketTransactions");
      if (savedTransactions) {
        cachedTransactions = JSON.parse(savedTransactions).map((t) => ({
          ...t,
          date: new Date(t.date)
        }));
      }
      if (typeof TribalWars === "undefined" || !TribalWars.getGameData) {
        isFetching = false;
        return reject("Dados do jogo TribalWars n\xE3o acess\xEDveis.");
      }
      try {
        const needsUpdate = await checkForUpdates();
        if (needsUpdate) {
          const transactions = await fetchAllPages();
          isFetching = false;
          resolve(transactions);
        } else {
          isFetching = false;
          resolve(cachedTransactions);
        }
      } catch (error) {
        isFetching = false;
        reject(error);
      }
    });
  };
  const fetchPage = async (pageNum = 1) => {
    const gameData = TribalWars.getGameData ? TribalWars.getGameData() : {};
    const villageId = gameData.village?.id || null;
    if (!villageId) {
      throw new Error("ID da vila n\xE3o encontrado no gameData");
    }
    const baseUrl = `${window.location.origin}/game.php?village=${villageId}&screen=premium&mode=log`;
    const url = pageNum === 1 ? baseUrl : `${baseUrl}&page=${pageNum - 1}`;
    try {
      const response = await fetchMarketData(url);
      if (!response) {
        throw new Error("Falha ao buscar logs premium");
      }
      const doc = new DOMParser().parseFromString(response, "text/html");
      const contentValue = doc.querySelector("#content_value");
      if (!contentValue) {
        throw new Error("N\xE3o foi poss\xEDvel encontrar o elemento #content_value");
      }
      let transactionTable = null;
      const tables = contentValue.querySelectorAll("table");
      for (const table of tables) {
        const headers = Array.from(table.querySelectorAll("th")).map((th) => th.textContent.trim().toLowerCase());
        if (headers.some((h) => h.includes("date") || h.includes("data")) && headers.some((h) => h.includes("world") || h.includes("mundo")) && headers.some((h) => h.includes("transaction") || h.includes("transa\xE7\xE3o"))) {
          transactionTable = table;
          break;
        }
      }
      let transactions = [];
      if (transactionTable) {
        const rows = Array.from(transactionTable.querySelectorAll("tr")).slice(1);
        transactions = parseTransactions(rows);
      }
      return { transactions, doc };
    } catch (error) {
      throw error;
    }
  };
  const parseDate = (dateStr) => {
    if (!dateStr || typeof dateStr !== "string") return /* @__PURE__ */ new Date(NaN);
    const locales = ["en-US", "pt-BR", "ru"];
    let parsedDate = null;
    for (const locale of locales) {
      parsedDate = DateTime.fromFormat(dateStr, "LLL dd, HH:mm", { locale });
      if (parsedDate.isValid) break;
    }
    if (!parsedDate || !parsedDate.isValid) {
      return /* @__PURE__ */ new Date(NaN);
    }
    const now = DateTime.now();
    let date = parsedDate.set({ year: now.year });
    if (date > now) {
      date = date.set({ year: now.year - 1 });
    }
    return date.toJSDate();
  };
  const parseTransactions = (rows) => {
    const transactions = [];
    const serverCode = window.location.hostname.includes("tribalwars.com.br") ? "br" : "us";
    rows.forEach((row) => {
      const cells = row.querySelectorAll("td");
      if (cells.length >= 6) {
        const date = parseDate(cells[0].textContent.trim());
        if (isNaN(date.getTime())) return;
        let displayedWorld = cells[1].textContent.trim();
        const worldNumberMatch = displayedWorld.match(/(\d+)$/);
        let world = displayedWorld;
        if (worldNumberMatch) {
          const worldNumber = worldNumberMatch[1];
          world = `${serverCode}${worldNumber}`;
        }
        const type = cells[2].textContent.trim();
        const changeMatch = cells[3].textContent.trim().match(/[-+]?\d+(?:\.\d+)?/);
        const pointsMatch = cells[4].textContent.trim().match(/\d+/);
        let transactionType = type;
        let changeValue = changeMatch ? parseFloat(changeMatch[0]) || 0 : 0;
        if (type === "Points redeemed" || type === "Pontos resgatados" || type === "Utilizado") {
          transactionType = "Despesa";
          changeValue = -Math.abs(changeValue);
        } else if (type === "Transfer" || type === "Transfer\xEAncia") {
          transactionType = changeValue < 0 ? "Despesa" : "Lucro";
        }
        transactions.push({
          date,
          type: transactionType,
          change: Math.floor(changeValue),
          newPremiumPoints: pointsMatch ? _.parseInt(pointsMatch[0], 10) || 0 : 0,
          // Lodash _.parseInt
          world
        });
      }
    });
    return transactions.sort((a, b) => b.date - a.date);
  };
  const calculateWorldProfit = () => {
    if (!state.transactions || !state.currentVillage?.world) return 0;
    const worldTransactions = state.transactions.filter((t) => t.world === state.currentVillage.world);
    const expenses = worldTransactions.filter((t) => t.change < 0 || t.type === "Despesa").reduce((sum, t) => sum + Math.abs(t.change), 0);
    const sales = worldTransactions.filter((t) => t.change > 0 || t.type === "Lucro").reduce((sum, t) => sum + t.change, 0);
    return Math.floor(sales - expenses);
  };
  const filterTransactions = (transactions, filters) => {
    if (!transactions) return [];
    const { dateFrom, dateTo, worldFilter } = filters;
    return _.filter(transactions, (t) => {
      if (isNaN(t.date.getTime())) return false;
      const dateFromDate = dateFrom ? new Date(dateFrom) : null;
      const dateToDate = dateTo ? new Date(dateTo) : null;
      const isDateValid = (!dateFromDate || t.date >= dateFromDate) && (!dateToDate || t.date <= dateToDate);
      let isWorldValid = true;
      if (worldFilter) {
        isWorldValid = t.world.toLowerCase().includes(worldFilter.toLowerCase().trim());
      }
      return isDateValid && isWorldValid;
    });
  };
  const sortTransactions = (transactions, sortField, sortDirection) => {
    return _.orderBy(transactions, [sortField], [sortDirection]);
  };
  const paginateTransactions = (transactions, page, perPage = 10) => {
    const start = (page - 1) * perPage;
    return _.slice(transactions, start, start + perPage);
  };
  const renderLedgerTable = (transactions, sortField = "date", sortDirection = "desc", page = 1, perPage = 10) => {
    const expenses = transactions.filter((t) => t.change < 0 || t.type === "Despesa");
    const sales = transactions.filter((t) => t.change > 0 || t.type === "Lucro");
    const totalExpenses = Math.floor(expenses.reduce((sum, t) => sum + Math.abs(t.change), 0));
    const totalSales = Math.floor(sales.reduce((sum, t) => sum + t.change, 0));
    const profit = Math.floor(totalSales - totalExpenses);
    const sortedExpenses = sortTransactions(expenses, sortField, sortDirection);
    const sortedSales = sortTransactions(sales, sortField, sortDirection);
    const allTransactions = [...sortedExpenses, ...sortedSales];
    const totalPages = Math.ceil(allTransactions.length / perPage);
    const paginated = paginateTransactions(allTransactions, page, perPage);
    ui.getElement("transactionsTableContainer").innerHTML = `
            <table class="ledger-table">
                <thead><tr>
                    <th data-sort="date">${i18n.t("date")}</th>
                    <th data-sort="type">${i18n.t("type")}</th>
                    <th data-sort="change">${i18n.t("change")}</th>
                    <th data-sort="world">${i18n.t("world")}</th>
                </tr></thead>
                <tbody>
                    <tr><td colspan="4" class="section-header">${i18n.t("expenses")}</td></tr>
                    ${paginated.filter((t) => t.change < 0 || t.type === "Despesa").map((t) => `
                        <tr>
                            <td>${t.date.toLocaleString()}</td>
                            <td>${t.type}</td>
                            <td><span class="icon header premium"></span> (${Math.abs(t.change)})</td>
                            <td>${t.world}</td>
                        </tr>
                    `).join("")}
                    <tr><td colspan="4" class="section-header">${i18n.t("sales")}</td></tr>
                    ${paginated.filter((t) => t.change > 0 || t.type === "Lucro").map((t) => `
                        <tr>
                            <td>${t.date.toLocaleString()}</td>
                            <td>${t.type}</td>
                            <td><span class="icon header premium"></span> ${t.change}</td>
                            <td>${t.world}</td>
                        </tr>
                    `).join("")}
                    <tr><td colspan="4" class="section-header">${i18n.t("profit")}: <span class="icon header premium"></span> ${profit}</td></tr>
                </tbody>
            </table>
        `;
    ui.getElement("paginationControls").innerHTML = `
           <button class="black-btn" id="prevPage" ${page === 1 ? "disabled" : ""}>${i18n.t("previous")}</button>
        <button class="black-btn" id="nextPage" ${page === totalPages || allTransactions.length === 0 ? "disabled" : ""}>${i18n.t("next")}</button>
    `;
    if (allTransactions.length > 0) {
      renderChart(allTransactions.sort((a, b) => a.date - b.date));
      ui.getElement("transactionsChart").style.display = "block";
    } else {
      ui.getElement("transactionsChart").style.display = "none";
    }
    ui.getElement("transactionsTableContainer").querySelectorAll("th[data-sort]").forEach(
      (header) => header.addEventListener("click", () => {
        const newSortField = header.dataset.sort;
        const newSortDirection = sortField === newSortField && sortDirection === "asc" ? "desc" : "asc";
        renderLedgerTable(transactions, newSortField, newSortDirection, page, perPage);
      })
    );
    ui.getElement("paginationControls").querySelector("#prevPage")?.addEventListener("click", () => page > 1 && renderLedgerTable(transactions, sortField, sortDirection, page - 1, perPage));
    ui.getElement("paginationControls").querySelector("#nextPage")?.addEventListener("click", () => page < totalPages && renderLedgerTable(transactions, sortField, sortDirection, page + 1, perPage));
  };
  let chartInstance = null;
  const renderChart = (transactions) => {
    const ctx = ui.getElement("transactionsChart").getContext("2d");
    if (chartInstance) chartInstance.destroy();
    const dates = [...new Set(transactions.map((t) => t.date.toLocaleDateString()))].sort((a, b) => new Date(a) - new Date(b));
    const data = dates.map((date) => {
      const dayTransactions = transactions.filter((t) => t.date.toLocaleDateString() === date);
      return Math.floor(dayTransactions.reduce((sum, t) => sum + t.change, 0));
    });
    chartInstance = new Chart(ctx, {
      type: "bar",
      data: {
        labels: dates,
        datasets: [{
          label: i18n.t("change"),
          data,
          backgroundColor: "#ffd700",
          borderColor: "#b8860b",
          borderWidth: 1
        }]
      },
      options: {
        responsive: true,
        scales: {
          x: { title: { display: true, text: i18n.t("date") } },
          y: { title: { display: true, text: i18n.t("change") }, beginAtZero: true }
        },
        plugins: {
          title: { display: true, text: i18n.t("chartTitle") }
        }
      }
    });
  };
  const renderTransactionsModal = (transactions, currentFilters, currentSortField, currentSortDirection, currentPage, perPage) => {
    ui.getElement("transactionsModal").querySelector(".modal-content").innerHTML = `
        <h3>${i18n.t("transactionsHeader")}</h3>
        <div id="filterSection"></div>
        <div id="transactionsTableContainer"></div>
        <div id="paginationControls" style="margin-top: 10px;"></div>
        <canvas id="transactionsChart" style="display: block; margin-top: 20px; max-width: 100%;"></canvas>
        <div style="margin-top: 10px;">
            ${createButton("closeModal", i18n.t("close"))}
        </div>
    `;
    ui.elements.set("filterSection", ui.getElement("transactionsModal").querySelector("#filterSection"));
    ui.elements.set("transactionsTableContainer", ui.getElement("transactionsModal").querySelector("#transactionsTableContainer"));
    ui.elements.set("paginationControls", ui.getElement("transactionsModal").querySelector("#paginationControls"));
    ui.elements.set("transactionsChart", ui.getElement("transactionsModal").querySelector("#transactionsChart"));
    ui.elements.set("closeModal", ui.getElement("transactionsModal").querySelector("#closeModal"));
    ui.getElement("filterSection").innerHTML = `
        <div>
            <label>${i18n.t("dateFrom")}: <input type="date" id="dateFrom" value="${currentFilters.dateFrom || ""}"></label>
            <label>${i18n.t("dateTo")}: <input type="date" id="dateTo" value="${currentFilters.dateTo || ""}"></label>
            <label>${i18n.t("worldFilter")}: <input type="text" id="worldFilter" value="${currentFilters.worldFilter || ""}"></label>
        </div>
    `;
    const debouncedApplyFilters = _.debounce(() => {
      currentFilters = {
        dateFrom: ui.getElement("filterSection").querySelector("#dateFrom").value,
        dateTo: ui.getElement("filterSection").querySelector("#dateTo").value,
        worldFilter: ui.getElement("filterSection").querySelector("#worldFilter").value
      };
      const filtered = filterTransactions(transactions, currentFilters);
      if (filtered.length === 0) {
        ui.getElement("transactionsTableContainer").innerHTML = `<p>${i18n.t("noTransactions")}</p>`;
        ui.getElement("paginationControls").innerHTML = "";
        ui.getElement("transactionsChart").style.display = "none";
      } else {
        renderLedgerTable(filtered, currentSortField, currentSortDirection, currentPage, perPage);
      }
    }, 300);
    ui.getElement("filterSection").querySelectorAll("input").forEach((input) => input.addEventListener("input", debouncedApplyFilters));
    debouncedApplyFilters();
    ui.getElement("closeModal").addEventListener("click", () => {
      ui.getElement("transactionsModal").style.display = "none";
      if (chartInstance) chartInstance.destroy();
      ui.getElement("transactionsChart").style.display = "none";
    });
  };
  const showTransactions = () => {
    if (!state.transactions || mobx.toJS(state.transactions).length === 0) {
      fetchAndUpdateProfit().then(() => {
        renderTransactionsModal(
          mobx.toJS(state.transactions),
          // Pass plain JS array
          {},
          "date",
          "desc",
          1,
          10
        );
        ui.getElement("transactionsModal").style.display = "flex";
      });
    } else {
      ui.getElement("transactionsModal").style.display = "flex";
      renderTransactionsModal(
        mobx.toJS(state.transactions),
        // Pass plain JS array
        {},
        "date",
        "desc",
        1,
        10
      );
    }
  };
  const fetchAndUpdateProfit = async () => {
    try {
      const transactions = await fetchPremiumLogs();
      if (!transactions || transactions.length === 0) {
        notifyUser(i18n.t("noTransactions"), "warning");
        state.transactions.replace([]);
        state.worldProfit = 0;
        updateUI();
        return;
      }
      state.transactions.replace(transactions);
      state.worldProfit = calculateWorldProfit();
      updateUI();
    } catch (error) {
      state.transactions.replace([]);
      notifyError(i18n.t("domError"));
      state.worldProfit = 0;
      updateUI();
    }
  };












    /**
 * Atualiza e salva APENAS o valor de premiumPoints na configuração
 * armazenada no localStorage usando LZString.
 * @param {number} newPPValue O novo valor numérico para premiumPoints.
 */
function updateAndSavePPConfig(newPPValue) {
    const configKey = "compressedConfig"; // Chave usada no localStorage
    const scriptId = `${SCRIPT_NAME}: [SavePP]`; // Para logs
    console.log(`${scriptId} Tentando salvar novo valor de PP: ${newPPValue}`);

    try {
        const compressedConfig = localStorage.getItem(configKey);
        let configData = {}; // Inicia como objeto vazio

        // 1. Carregar e Descompactar Configuração Existente (se houver)
        if (compressedConfig) {
            try {
                const decompressed = LZString.decompress(compressedConfig);
                // Verifica se a descompressão retornou algo válido antes de parsear
                if (decompressed) {
                    configData = JSON.parse(decompressed);
                    console.log(`${scriptId} Configuração existente descomprimida com sucesso.`);
                } else {
                    // Se a descompressão falhar (retorna null ou string vazia), trate como config vazia
                     console.warn(`${scriptId} Descompressão da config existente retornou null/vazio. Iniciando com config vazia.`);
                     // Opcional: Remover item corrompido? localStorage.removeItem(configKey);
                }
            } catch (parseError) {
                // Se o JSON.parse falhar, também trate como config vazia
                console.error(`${scriptId} Erro ao parsear JSON da config descomprimida:`, parseError, ". Iniciando com config vazia.");
                 // Opcional: Remover item corrompido? localStorage.removeItem(configKey);
            }
        } else {
            console.log(`${scriptId} Nenhuma configuração salva encontrada. Criando nova config.`);
        }

        // 2. Atualizar o Valor de premiumPoints
        // Garante que seja um número não negativo e converte para string para salvar
        configData.premiumPoints = String(Math.max(0, sanitizeNumber(newPPValue)));
        console.log(`${scriptId} configData.premiumPoints atualizado para: '${configData.premiumPoints}'`);

        // 3. Compactar e Salvar de Volta
        const newCompressedConfig = LZString.compress(JSON.stringify(configData));

        // Verifica se a compressão funcionou antes de salvar
        if (newCompressedConfig) {
            localStorage.setItem(configKey, newCompressedConfig);
            console.log(`${scriptId} Nova configuração (com PP atualizado) salva com sucesso no localStorage.`);
        } else {
            // Isso é muito raro, mas pode acontecer se JSON.stringify falhar ou LZString.compress falhar
            console.error(`${scriptId} ERRO CRÍTICO: Compressão resultou em valor nulo/vazio. Salvamento falhou!`);
            notifyError("Falha crítica ao tentar salvar automaticamente o limite de PP.");
        }

    } catch (error) {
        // Captura erros gerais (ex: localStorage cheio, erro inesperado no LZString)
        console.error(`${scriptId} ERRO GERAL durante a atualização/salvamento da config de PP:`, error);
        notifyError("Erro ao salvar automaticamente o limite de PP.");
    }
}

















 /*/**
 * Executa a transação de compra ou venda no jogo.
 * CORRIGIDO: Regex para extrair custo do popup de compra.
 * ATUALIZADO: Salva automaticamente o novo limite de PP no localStorage após compra.
 * Adiciona logs detalhados.
 * Tenta atualizar VISUALMENTE o input de PP ANTES do clique de confirmação.
 *
 * @param {string} type 'buy' ou 'sell'
 * @param {ResourceHandler} resource O objeto ResourceHandler do recurso
 * @param {number} amount A quantidade a ser transacionada
 */
const executeTransaction = (type, resource, amount) => {
    const transactionId = Date.now();
    console.log(`${SCRIPT_NAME}: [TX-${transactionId} - ${type}] Iniciando transação para ${resource.name}, Quantidade: ${amount}`);

    const isBuy = type === "buy";
    const input = isBuy ? ui.buyInputs.get(resource.name) : ui.sellInputs.get(resource.name);

    const actionButton = isBuy
        ? document.querySelector('input.btn-premium-exchange-buy[type="submit"]')
        : document.querySelector('#premium_exchange_form input.btn[type="submit"]');

    const transactionSpinner = isBuy ? ui.getElement("buySpinner") : ui.getElement("sellSpinner");

    if (!input || !actionButton) {
        console.error(`${SCRIPT_NAME}: [TX-${transactionId} - ${type}] Erro Crítico: Input (${input ? 'OK' : 'FALHA'}) ou Botão de Ação (${actionButton ? 'OK' : 'FALHA'}) não encontrado para ${resource.name}. Tentando atualizar elementos DOM e agendando reload.`);
        updateGameElements();
        notifyError(i18n.t("domError"));
        scheduleReload();
        if (isBuy) isProcessingBuy = false; else isProcessingSell = false;
        return;
    }

    if (transactionSpinner) {
        transactionSpinner.style.display = "inline-block";
        console.log(`${SCRIPT_NAME}: [TX-${transactionId} - ${type}] Spinner ativado.`);
    }
    notifyUser(i18n.t("transactionInProgress"), "warning");
    console.log(`${SCRIPT_NAME}: [TX-${transactionId} - ${type}] Notificação 'Processando' exibida.`);

    const handleActionButtonClick = () => {
        console.log(`${SCRIPT_NAME}: [TX-${transactionId} - ${type}] handleActionButtonClick iniciado.`);
        if (actionButton.disabled) {
            console.log(`${SCRIPT_NAME}: [TX-${transactionId} - ${type}] Botão de ação desabilitado, iniciando MutationObserver.`);
            const observer = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    if (mutation.attributeName === "disabled" && !actionButton.disabled) {
                        console.log(`${SCRIPT_NAME}: [TX-${transactionId} - ${type}] Botão de ação habilitado pelo observer. Desconectando observer e clicando.`);
                        observer.disconnect();
                        actionButton.click();
                        startConfirmationCheck();
                    }
                });
            });
            observer.observe(actionButton, { attributes: true, attributeFilter: ["disabled"] });
        } else {
            console.log(`${SCRIPT_NAME}: [TX-${transactionId} - ${type}] Botão de ação já habilitado. Clicando diretamente.`);
            actionButton.click();
            startConfirmationCheck();
        }
    };

    const startConfirmationCheck = () => {
        console.log(`${SCRIPT_NAME}: [TX-${transactionId} - ${type}] Iniciando busca pelo pop-up de confirmação (startConfirmationCheck).`);
        let attempts = 0;
        const maxAttempts = 50;
        let confirmationProcessed = false;

        const interval = setInterval(() => {
            if (confirmationProcessed) {
                clearInterval(interval);
                console.log(`${SCRIPT_NAME}: [TX-${transactionId} - ${type}] Intervalo de confirmação limpo.`);
                return;
            }

            console.log(`${SCRIPT_NAME}: [TX-${transactionId} - ${type}] Tentativa ${attempts + 1}/${maxAttempts} para encontrar pop-up e botão.`);

            const popupSelectors = [
                "div.ui-dialog[aria-describedby='premium_exchange_confirm_buy']",
                "div.ui-dialog[aria-describedby='premium_exchange_confirm_sell']",
                "div.ui-dialog:not([style*='display: none'])",
                "div[role='dialog']:not([style*='display: none'])"
            ];
            let popup = null;
            for (const selector of popupSelectors) {
                popup = document.querySelector(selector);
                if (popup && (!popup.style.display || popup.style.display !== 'none')) {
                    console.log(`${SCRIPT_NAME}: [TX-${transactionId} - ${type}] Pop-up encontrado com seletor: ${selector}`);
                    break;
                }
            }

            if (popup) {
                const confirmButtonSelectors = [
                   'div.confirmation-buttons button.btn.evt-confirm-btn.btn-confirm-yes',
                   'button.btn-confirm-yes',
                   'button:enabled:contains("Sim")',
                   'button:enabled:contains("Yes")',
                   '.ui-dialog-buttonpane button:not(:disabled):first-of-type'
                ];
                let confirmButton = null;
                for (const selector of confirmButtonSelectors) {
                    confirmButton = popup.querySelector(selector);
                    if (confirmButton && !confirmButton.disabled) {
                        console.log(`${SCRIPT_NAME}: [TX-${transactionId} - ${type}] Botão 'Sim' encontrado e HABILITADO com seletor: ${selector}`);
                        break;
                    }
                }

                if (confirmButton) {
                    clearInterval(interval);
                    confirmationProcessed = true;
                    console.log(`${SCRIPT_NAME}: [TX-${transactionId} - ${type}] Botão 'Sim' confirmado. Processando pré-clique.`);

                    let premiumCost = 0;
                    if (isBuy) {
                        console.log(`${SCRIPT_NAME}: [TX-${transactionId} - Compra] Tentando extrair custo do PP.`);
                        try {
                            const costMsgSelectors = ["#confirmation-msg p", ".dialog_content p", ".ui-dialog-content p"];
                            let costMsgElement = null;
                            for(const selector of costMsgSelectors) {
                                costMsgElement = popup.querySelector(selector);
                                if(costMsgElement) {
                                    console.log(`${SCRIPT_NAME}: [TX-${transactionId} - Compra] Elemento de mensagem encontrado com seletor: ${selector}`);
                                    break;
                                }
                            }

                            if (costMsgElement) {
                                const msgHTML = costMsgElement.innerHTML;
                                console.log(`${SCRIPT_NAME}: [TX-${transactionId} - Compra] HTML da Mensagem: ${msgHTML}`);
                                const costRegex = /<img\s[^>]*src="[^"]*premium\.png"[^>]*>\s*(\d+)/i;
                                const costMatch = msgHTML.match(costRegex);
                                if (costMatch && costMatch[1]) {
                                    premiumCost = sanitizeNumber(costMatch[1]);
                                    console.log(`${SCRIPT_NAME}: [TX-${transactionId} - Compra] Custo em PP extraído: ${premiumCost} (NOVA Regex OK)`);
                                } else {
                                    console.warn(`${SCRIPT_NAME}: [TX-${transactionId} - Compra] NOVA Regex não encontrou o custo no HTML da mensagem.`);
                                }
                            } else {
                                console.warn(`${SCRIPT_NAME}: [TX-${transactionId} - Compra] Elemento da mensagem de custo NÃO encontrado.`);
                            }
                        } catch (e) {
                            console.error(`${SCRIPT_NAME}: [TX-${transactionId} - Compra] Erro CRÍTICO ao tentar extrair/processar custo do PP no pop-up:`, e);
                        }
                    }

                    // --- Atualização Visual e SALVAMENTO AUTOMÁTICO ---
                    if (isBuy && premiumCost > 0) {
                        console.log(`${SCRIPT_NAME}: [TX-${transactionId} - Compra] Custo ${premiumCost} > 0. Tentando atualizar input e salvar config.`);
                        const premiumInput = ui.getElement("premiumPointsInput");
                        if (premiumInput) {
                            console.log(`${SCRIPT_NAME}: [TX-${transactionId} - Compra] Input de PP encontrado.`);
                            const currentPPInInput = sanitizeNumber(premiumInput.value) || 0;
                            console.log(`${SCRIPT_NAME}: [TX-${transactionId} - Compra] Valor ATUAL no input: ${currentPPInInput}`);
                            const newPP = Math.max(0, currentPPInInput - premiumCost);
                            console.log(`${SCRIPT_NAME}: [TX-${transactionId} - Compra] Novo valor CALCULADO para input: ${newPP}`);

                            premiumInput.value = newPP; // ATUALIZA VISUALMENTE ANTES DO CLIQUE
                            console.log(`${SCRIPT_NAME}: [TX-${transactionId} - Compra] Input visualmente atualizado para ${newPP}.`);

                            // *** CHAMA A FUNÇÃO DE SALVAMENTO AUTOMÁTICO ***
                            updateAndSavePPConfig(newPP);
                            // **********************************************

                        } else {
                           console.warn(`${SCRIPT_NAME}: [TX-${transactionId} - Compra] Input #premiumPointsInput NÃO encontrado.`);
                        }
                    } else if (isBuy) {
                         console.log(`${SCRIPT_NAME}: [TX-${transactionId} - Compra] Custo do PP foi 0 ou não pôde ser extraído. Input e config não serão atualizados.`);
                    }
                    // --- Fim da Atualização e Salvamento ---

                    console.log(`${SCRIPT_NAME}: [TX-${transactionId} - ${type}] Clicando no botão 'Sim' AGORA.`);
                    confirmButton.click();

                    if (transactionSpinner) {
                        transactionSpinner.style.display = "none";
                        console.log(`${SCRIPT_NAME}: [TX-${transactionId} - ${type}] Spinner desativado.`);
                    }
                    notifySuccess(i18n.t("transactionSuccess"));
                    console.log(`${SCRIPT_NAME}: [TX-${transactionId} - ${type}] Notificação 'Sucesso' exibida. Agendando reload.`);
                    scheduleReload();
                    return;

                } else {
                    const simButton = popup.querySelector('button.btn-confirm-yes');
                    if(simButton){
                        console.log(`${SCRIPT_NAME}: [TX-${transactionId} - ${type}] Botão 'Sim' encontrado, mas DESABILITADO. Aguardando próxima verificação.`);
                    } else {
                        console.log(`${SCRIPT_NAME}: [TX-${transactionId} - ${type}] Botão 'Sim' NÃO encontrado nesta tentativa. Aguardando próxima verificação.`);
                    }
                }

            } else {
                 console.log(`${SCRIPT_NAME}: [TX-${transactionId} - ${type}] Pop-up de confirmação ainda não encontrado/visível.`);
            }

            attempts++;
            if (attempts >= maxAttempts) {
                clearInterval(interval);
                confirmationProcessed = true;
                console.warn(`${SCRIPT_NAME}: [TX-${transactionId} - ${type}] TIMEOUT: Pop-up/botão não encontrado após ${maxAttempts} tentativas. Assumindo erro.`);
                if (transactionSpinner) {
                    transactionSpinner.style.display = "none";
                }
                notifyError(i18n.t("transactionError") + " (Timeout Confirmação)");
                console.log(`${SCRIPT_NAME}: [TX-${transactionId} - ${type}] Agendando reload devido ao timeout.`);
                scheduleReload();
                if (isBuy) isProcessingBuy = false; else isProcessingSell = false;
            }
        }, 100);
    };

    const finalAmount = sanitizeNumber(amount);
    if (isNaN(finalAmount) || finalAmount <= 0) {
        console.error(`${SCRIPT_NAME}: [TX-${transactionId} - ${type}] Quantidade inválida (${amount} -> ${finalAmount}). Transação abortada.`);
        if (transactionSpinner) transactionSpinner.style.display = "none";
        if (isBuy) isProcessingBuy = false; else isProcessingSell = false;
        return;
    }

    console.log(`${SCRIPT_NAME}: [TX-${transactionId} - ${type}] Preenchendo input com quantidade: ${finalAmount}`);
    input.value = finalAmount;

    console.log(`${SCRIPT_NAME}: [TX-${transactionId} - ${type}] Disparando eventos input, change, keyup.`);
    input.dispatchEvent(new Event('input', { bubbles: true }));
    input.dispatchEvent(new Event('change', { bubbles: true }));
    input.dispatchEvent(new Event('keyup', { bubbles: true }));

    console.log(`${SCRIPT_NAME}: [TX-${transactionId} - ${type}] Agendando handleActionButtonClick em 150ms.`);
    setTimeout(handleActionButtonClick, 150);

}; // --- Fim da função executeTransaction ---


  const calculateMaxBuyAmount = (resource) => {
    const gameRate = resource.getGameRate();
    const userRate = resource.getUserRate();
    const stock = resource.getStock();
    const output = resource.config.outputDefault;
    const buyPerTime = sanitizeNumber(ui.getElement("buyPerTimeInput").value);
    const storageLimit = sanitizeNumber(ui.getElement("storageLimitInput").value) || 1e3;
    const maxSpend = sanitizeNumber(ui.getElement("maxSpendInput").value);
    if (gameRate <= 0 || userRate <= 0 || stock <= 0 || maxSpend <= 0) return 0;
    const adjustedStorageLimit = Math.max(0, storageLimit - output);
    if (gameRate < userRate) return 0;
    let maxBuyAmount = stock < buyPerTime ? stock : Math.min(maxSpend * gameRate, buyPerTime, adjustedStorageLimit, stock);
    return Math.max(0, Math.floor(maxBuyAmount));
  };
  const calculateAvailableCapacityForResource = async (resourceName) => {
    const storageCapacity = state.storageCapacity;
    const currentStock = currentResources[resourceName];
    const incomingResources = await fetchTransportData();
    const totalStock = currentStock + incomingResources[resourceName];
    return Math.max(0, storageCapacity - totalStock);
  };
  let isProcessingBuy = false;
  const processBuyBasedOnResources = async () => {
    if (!state.buyModeActive || isProcessingBuy) {
      return;
    }
    isProcessingBuy = true;
    try {
      await fetchIncomingResources();
    } catch (error) {
    }
    state.storageCapacity = getStorageCapacity();
    const availablePP = getAvailablePremiumPoints();
    const premiumInput = ui.getElement("premiumPointsInput");
    const maxPP = premiumInput ? sanitizeNumber(premiumInput.value) : Infinity;
    const effectivePP = Math.min(availablePP, maxPP);
    if (effectivePP <= 0) {
      state.hasExecutedBuy = false;
      isProcessingBuy = false;
      return;
    }
    const workerData = {
      action: "calculateBuyAmount",
      data: {
        resources: Object.keys(resources).map((name) => {
          const handler = resources[name];
          const desiredStockInput = document.querySelector(`.rate-input[data-resource="${name}-stock"]`);
          const desiredStock = sanitizeNumber(desiredStockInput?.value) || 0;
          const userRateLimitInput = document.querySelector(`.rate-input[data-resource="${name}"]`);
          const userRateLimit = sanitizeNumber(userRateLimitInput?.value) || 0;
          const buyLimitPerTime = sanitizeNumber(ui.getElement("buyPerTimeInput")?.value) || Infinity;
          return {
            name,
            desiredStock,
            marketRate: handler.getGameRate() || 0,
            userRateLimit,
            buyLimitPerTime
          };
        }),
        effectivePP,
        storageCapacity: state.storageCapacity,
        incomingResources: { ...state.incomingResources },
        currentResources: { ...currentResources }
      }
    };
    worker.postMessage(workerData);
    worker.onmessage = async (e) => {
      if (e.data.action === "buyAmountCalculated") {
        const { amountToBuy, resourceName } = e.data.result;
        if (amountToBuy > 0 && resourceName) {
          const handler = resources[resourceName];
          console.log(`[Compra] Tentando comprar ${amountToBuy} ${resourceName}`);
          const initialPremium = getAvailablePremiumPoints();
          const initialStock = currentResources[resourceName] || 0;
          await executeTransaction("buy", handler, amountToBuy);
          state.hasExecutedBuy = true;
          await new Promise((resolve) => setTimeout(resolve, 1e3));
          const finalPremium = getAvailablePremiumPoints();
          const finalStock = currentResources[resourceName] || 0;
          const premiumSpent = initialPremium - finalPremium;
          const stockIncreased = finalStock > initialStock;
          if (premiumInput && premiumInput.value !== "0" && (premiumSpent > 0 || stockIncreased)) {
            const newPP = Math.max(0, maxPP - premiumSpent);
            premiumInput.value = newPP;
            console.log(`[Compra] Transa\xE7\xE3o confirmada. Pontos premium gastos: ${premiumSpent}, Novo valor no input: ${newPP}`);
          } else {
            console.log(`[Compra] Transa\xE7\xE3o n\xE3o confirmada (PP inicial: ${initialPremium}, PP final: ${finalPremium}, Estoque inicial: ${initialStock}, Estoque final: ${finalStock})`);
          }
        } else {
          console.log("[Compra] Nenhum recurso eleg\xEDvel para compra");
          state.hasExecutedBuy = false;
        }
      }
      isProcessingBuy = false;
    };
    worker.onerror = (error) => {
      console.error("[Compra] Erro no Worker:", error);
      isProcessingBuy = false;
    };
  };
  function getAvailablePremiumPoints() {
    const premiumElement = document.querySelector("#premium_points");
    return premiumElement ? sanitizeNumber(premiumElement.textContent.trim()) : 0;
  }
  const resetBuyInputs = () => ui.buyInputs.forEach((input) => input && (input.value = ""));
  const updateMaxSpend = (change) => {
    const currentValue = sanitizeNumber(ui.getElement("maxSpendInput").value);
    const newValue = Math.max(0, currentValue + change);
    ui.getElement("maxSpendInput").value = newValue;
    localStorage.setItem("max-spend", String(newValue));
    console.log(`[UpdateMaxSpend] Novo valor de maxSpend: ${newValue}`);
  };
  const fetchTransportData = async () => {
    const gameData = TribalWars.getGameData();
    const villageId = gameData.village.id;
    const world = getActiveWorld();
    const url = `https://${world}.tribalwars.com.br/game.php?village=${villageId}&screen=market&mode=transports`;
    try {
      const response = await fetchMarketData(url);
      if (!response) throw new Error("Falha ao buscar dados de transporte");
      const doc = new DOMParser().parseFromString(response, "text/html");
      const transportRows = doc.querySelectorAll(".transport_row");
      const incomingResources = {
        wood: 0,
        stone: 0,
        iron: 0
      };
      transportRows.forEach((row) => {
        const direction = row.querySelector(".transport_direction").textContent;
        if (direction.includes("Para esta aldeia")) {
          const resourceType = row.querySelector(".transport_resource").dataset.type;
          const amount = sanitizeNumber(row.querySelector(".transport_amount").textContent);
          incomingResources[resourceType] += amount;
        }
      });
      return incomingResources;
    } catch (error) {
      console.error("[Transporte] Falha ao obter dados:", error);
      return { wood: 0, stone: 0, iron: 0 };
    }
  };
  const transportLogger = {
    log: () => {
    },
    // Does nothing
    error: () => {
    },
    // Does nothing
    warn: () => {
    },
    // Does nothing
    debug: () => {
    }
    // Does nothing
  };
  function parseIntSafeTransport(str) {
    if (typeof str !== "string" || !str) return 0;
    const cleanedStr = str.replace(/[.,]/g, "").replace(/[^\d]/g, "");
    const num = parseInt(cleanedStr, 10);
    return isNaN(num) ? 0 : num;
  }
  function extractResourcesFromElement(element) {
    const resources2 = { wood: 0, stone: 0, iron: 0 };
    if (!element) return resources2;
    const woodIcon = element.querySelector(".icon.header.wood");
    const stoneIcon = element.querySelector(".icon.header.stone");
    const ironIcon = element.querySelector(".icon.header.iron");
    const getValueNearIcon = (icon) => {
      if (!icon) return 0;
      let potentialValueElement = icon.nextElementSibling;
      if (potentialValueElement && potentialValueElement.textContent.match(/[\d.,]+/)) {
        if (!potentialValueElement.querySelector(".icon.header")) {
          return parseIntSafeTransport(potentialValueElement.textContent);
        }
      }
      let nextNode = icon.nextSibling;
      while (nextNode && nextNode.nodeType !== Node.TEXT_NODE) {
        if (nextNode.nodeType === Node.ELEMENT_NODE && nextNode.textContent.match(/[\d.,]+/)) {
          if (!nextNode.querySelector(".icon.header")) {
            return parseIntSafeTransport(nextNode.textContent);
          }
        }
        nextNode = nextNode.nextSibling;
      }
      if (nextNode && nextNode.nodeType === Node.TEXT_NODE) {
        const numberMatch = nextNode.textContent.trim().match(/^[\s]*([\d.,]+)/);
        if (numberMatch) {
          return parseIntSafeTransport(numberMatch[1]);
        }
      }
      let parent = icon.parentElement;
      if (parent && parent.textContent) {
        const parentText = parent.textContent.trim();
        const potentialValues = parentText.match(/([\d.,]+)/g);
        if (potentialValues && potentialValues.length >= 1) {
        }
      }
      return 0;
    };
    resources2.wood = getValueNearIcon(woodIcon);
    resources2.stone = getValueNearIcon(stoneIcon);
    resources2.iron = getValueNearIcon(ironIcon);
    if (resources2.wood === 0 && resources2.stone === 0 && resources2.iron === 0 && (woodIcon || stoneIcon || ironIcon)) {
      transportLogger.debug("Icon-based extraction failed, attempting text-based fallback within element:", element.textContent.substring(0, 100));
      const textContent = element.textContent || "";
      const numbers = (textContent.match(/[\d.,]+/g) || []).map((n) => parseIntSafeTransport(n));
      let numIndex = 0;
      if (woodIcon && numIndex < numbers.length) {
        resources2.wood = numbers[numIndex];
        numIndex++;
      }
      if (stoneIcon && numIndex < numbers.length) {
        resources2.stone = numbers[numIndex];
        numIndex++;
      }
      if (ironIcon && numIndex < numbers.length) {
        resources2.iron = numbers[numIndex];
        numIndex++;
      }
      transportLogger.debug(" - Text fallback results:", resources2);
      if (numIndex === 1 && [woodIcon, stoneIcon, ironIcon].filter(Boolean).length > 1) {
        transportLogger.warn("Single number found for multiple icons via text fallback, resetting as likely incorrect.");
        return { wood: 0, stone: 0, iron: 0 };
      }
    }
    return resources2;
  }
  function parseTransportData(html) {
    transportLogger.log("Iniciando parseamento da p\xE1gina de transportes.");
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, "text/html");
    const incoming = { madeira: 0, argila: 0, ferro: 0 };
    let foundIncomingData = false;
    const allText = doc.body.textContent.toLowerCase();
    if (allText.includes("n\xE3o h\xE1 transportes chegando") || allText.includes("nenhum transporte em chegada") || allText.includes("no incoming transports") || allText.includes("\u043D\u0435\u0442 \u0432\u0445\u043E\u0434\u044F\u0449\u0438\u0445 \u0442\u0440\u0430\u043D\u0441\u043F\u043E\u0440\u0442\u043E\u0432")) {
      transportLogger.log("P\xE1gina indica explicitamente que n\xE3o h\xE1 transportes de chegada.");
      return incoming;
    }
    let incomingTable = null;
    incomingTable = doc.querySelector("#market_transports_in table.vis, #market_transports_in, #market_status_in table.vis");
    if (!incomingTable) {
      const headers = Array.from(doc.querySelectorAll("h2, h3, h4, .content-header, .box-header, th, .table-header"));
      const incomingKeywords = [
        "transportes em chegada",
        "entrando",
        "incoming transports",
        "chegando",
        "mercadores chegando",
        "arrival",
        "\u043F\u0440\u0438\u0431\u044B\u0432\u0430\u044E\u0449\u0438\u0435 \u0442\u0440\u0430\u043D\u0441\u043F\u043E\u0440\u0442\u044B",
        "chegada",
        "transporte de entrada",
        "transporte chegando",
        "\u0442\u0440\u0430\u043D\u0441\u043F\u043E\u0440\u0442 \u043F\u0440\u0438\u0431\u044B\u0442\u0438\u044F"
      ];
      for (const header of headers) {
        const headerText = header.textContent.trim().toLowerCase();
        if (incomingKeywords.some((keyword) => headerText.includes(keyword))) {
          transportLogger.log(`Cabe\xE7alho de chegada encontrado: "${headerText}"`);
          let current = header;
          let searchLimit = 5;
          while (current && searchLimit > 0) {
            if (current.tagName === "TABLE" && current.classList.contains("vis")) {
              incomingTable = current;
              break;
            }
            const tableInside = current.querySelector("table.vis");
            if (tableInside) {
              incomingTable = tableInside;
              break;
            }
            current = current.nextElementSibling;
            searchLimit--;
          }
          if (incomingTable) {
            transportLogger.log(`Tabela de chegada encontrada pr\xF3xima ao cabe\xE7alho "${headerText}"`);
            break;
          }
        }
      }
    }
    if (incomingTable) {
      transportLogger.log("Processando tabela de chegada encontrada...");
      const rows = Array.from(incomingTable.querySelectorAll("tr")).filter(
        (row) => !row.querySelector("th") && row.cells && row.cells.length > 1
      );
      const summaryRow = Array.from(incomingTable.querySelectorAll("tr")).find((row) => {
        const text = row.textContent.toLowerCase();
        return (text.includes("total:") || text.includes("soma:") || text.includes("summe:") || text.includes("\u0438\u0442\u043E\u0433\u043E:") || text.includes("entrada:")) && !row.querySelector("th");
      });
      if (summaryRow) {
        transportLogger.log("Processando linha de sum\xE1rio de chegada...");
        const resources2 = extractResourcesFromElement(summaryRow);
        if (resources2.wood > 0 || resources2.stone > 0 || resources2.iron > 0) {
          incoming.madeira = resources2.wood;
          incoming.argila = resources2.stone;
          incoming.ferro = resources2.iron;
          foundIncomingData = true;
          transportLogger.log("Recursos extra\xEDdos da linha de sum\xE1rio:", incoming);
        }
      } else if (rows.length > 0) {
        transportLogger.log(`Processando ${rows.length} linhas de dados na tabela de chegada...`);
        rows.forEach((row, index) => {
          const resources2 = extractResourcesFromElement(row);
          if (resources2.wood > 0 || resources2.stone > 0 || resources2.iron > 0) {
            incoming.madeira += resources2.wood;
            incoming.argila += resources2.stone;
            incoming.ferro += resources2.iron;
            foundIncomingData = true;
            transportLogger.debug(`Linha ${index}: Recursos adicionados: W=${resources2.wood}, S=${resources2.stone}, I=${resources2.iron}`);
          }
        });
        transportLogger.log("Total de recursos encontrados:", incoming);
      } else {
        transportLogger.warn("Tabela de chegada encontrada, mas sem linhas de dados ou sum\xE1rio reconhec\xEDvel.");
      }
    } else {
      transportLogger.warn("Nenhuma tabela espec\xEDfica de chegada encontrada. Tentando estrat\xE9gia alternativa...");
    }
    if (!foundIncomingData) {
      transportLogger.log("Buscando linhas de transporte gerais e verificando dire\xE7\xE3o...");
      const allPossibleRows = [
        ...doc.querySelectorAll(".transport_row"),
        ...doc.querySelectorAll('tr[id^="market_"]'),
        ...doc.querySelectorAll("tr.row_a, tr.row_b"),
        // Padrão comum de linhas alternadas
        ...doc.querySelectorAll("table.vis tr:not(:first-child)")
        // Todas as linhas não-cabeçalho de qualquer tabela
      ];
      if (allPossibleRows.length > 0) {
        transportLogger.log(`Encontradas ${allPossibleRows.length} poss\xEDveis linhas de transporte para an\xE1lise.`);
        allPossibleRows.forEach((row, index) => {
          let isIncoming = false;
          const rowText = row.textContent.toLowerCase();
          const rowHTML = row.innerHTML.toLowerCase();
          const incomingKeywords = [
            "para esta aldeia",
            "incoming",
            "arrival",
            "chegada",
            "chegando",
            "entrada",
            "para c\xE1",
            "entrando",
            "recebendo"
          ];
          const incomingSymbols = [
            "arrow_right",
            "arrow_in",
            "icon_in",
            "\u2192",
            "\u25B6",
            "\u21E8"
          ];
          if (incomingKeywords.some((keyword) => rowText.includes(keyword)) || incomingSymbols.some((symbol) => rowHTML.includes(symbol))) {
            isIncoming = true;
          }
          const directionElement = row.querySelector(".transport_direction, .direction, .movement-direction");
          if (directionElement) {
            const directionText = directionElement.textContent.trim().toLowerCase();
            const directionHTML = directionElement.innerHTML.toLowerCase();
            if (incomingKeywords.some((keyword) => directionText.includes(keyword)) || incomingSymbols.some((symbol) => directionHTML.includes(symbol))) {
              isIncoming = true;
            }
          }
          if (isIncoming) {
            transportLogger.debug(`Linha ${index} identificada como CHEGANDO`);
            const resourceCell = row.querySelector(".resources_sum, .res") || row;
            const resources2 = extractResourcesFromElement(resourceCell);
            if (resources2.wood > 0 || resources2.stone > 0 || resources2.iron > 0) {
              incoming.madeira += resources2.wood;
              incoming.argila += resources2.stone;
              incoming.ferro += resources2.iron;
              foundIncomingData = true;
              transportLogger.debug(`Recursos adicionados: W=${resources2.wood}, S=${resources2.stone}, I=${resources2.iron}`);
            }
          }
        });
      } else {
        transportLogger.error("Nenhuma linha de transporte encontrada em toda a p\xE1gina.");
      }
    }
    if (!foundIncomingData) {
      transportLogger.log("Tentando encontrar elementos de sum\xE1rio de recursos...");
      const summaryElements = [
        doc.querySelector("#market_status_in"),
        doc.querySelector(".incoming-resources"),
        doc.querySelector(".resources-incoming"),
        ...doc.querySelectorAll(".sum_incoming"),
        ...doc.querySelectorAll(".incoming_total")
      ].filter(Boolean);
      for (const element of summaryElements) {
        const resources2 = extractResourcesFromElement(element);
        if (resources2.wood > 0 || resources2.stone > 0 || resources2.iron > 0) {
          incoming.madeira = resources2.wood;
          incoming.argila = resources2.stone;
          incoming.ferro = resources2.iron;
          foundIncomingData = true;
          transportLogger.log("Recursos encontrados em elemento de sum\xE1rio:", incoming);
          break;
        }
      }
    }
    if (foundIncomingData) {
      transportLogger.log("Parseamento conclu\xEDdo com sucesso. Recursos CHEGANDO:", incoming);
      return { madeira: incoming.madeira, argila: incoming.argila, ferro: incoming.ferro };
    } else {
      transportLogger.error("N\xE3o foi poss\xEDvel encontrar dados de transportes em chegada na p\xE1gina.");
      return { madeira: 0, argila: 0, ferro: 0 };
    }
  }
  async function fetchIncomingResources() {
    return new Promise((resolve, reject) => {
      const gameData = typeof TribalWars !== "undefined" && TribalWars.getGameData ? TribalWars.getGameData() : {};
      const villageId = gameData.village?.id;
      if (!villageId) {
        transportLogger.error("[Fetch] ID da vila n\xE3o encontrado.");
        mobx.runInAction(() => {
          state.incomingResources.wood = 0;
          state.incomingResources.stone = 0;
          state.incomingResources.iron = 0;
        });
        return resolve({ wood: 0, stone: 0, iron: 0 });
      }
      const transportUrl = `https://${window.location.host}/game.php?village=${villageId}&screen=market&mode=transports`;
      transportLogger.log(`[Fetch] Buscando dados de transporte de: ${transportUrl}`);
      GM_xmlhttpRequest({
        method: "GET",
        url: transportUrl,
        timeout: 15e3,
        // Timeout can be adjusted
        onload: (response) => {
          if (response.status >= 200 && response.status < 300) {
            transportLogger.log("[Fetch] Resposta da p\xE1gina de transporte recebida (Status OK).");
            try {
              const incomingData = parseTransportData(response.responseText);
              if (incomingData === null) {
                transportLogger.error("[Fetch] parseTransportData retornou null (falha ao encontrar/parsear dados). Resolvendo com recursos zerados.");
                mobx.runInAction(() => {
                  state.incomingResources.wood = 0;
                  state.incomingResources.stone = 0;
                  state.incomingResources.iron = 0;
                });
                resolve({ wood: 0, stone: 0, iron: 0 });
              } else {
                transportLogger.log("[Fetch] Atualizando state.incomingResources:", incomingData);
                mobx.runInAction(() => {
                  state.incomingResources.wood = incomingData.madeira || 0;
                  state.incomingResources.stone = incomingData.argila || 0;
                  state.incomingResources.iron = incomingData.ferro || 0;
                });
                resolve({
                  wood: state.incomingResources.wood,
                  // Resolve with state values
                  stone: state.incomingResources.stone,
                  iron: state.incomingResources.iron
                });
              }
            } catch (parseError) {
              transportLogger.error(`[Fetch] Erro durante o parseamento: ${parseError.message}`, parseError);
              mobx.runInAction(() => {
                state.incomingResources.wood = 0;
                state.incomingResources.stone = 0;
                state.incomingResources.iron = 0;
              });
              reject(parseError);
            }
          } else {
            transportLogger.error(`[Fetch] Falha ao buscar dados de transporte. Status: ${response.status}`);
            mobx.runInAction(() => {
              state.incomingResources.wood = 0;
              state.incomingResources.stone = 0;
              state.incomingResources.iron = 0;
            });
            reject(new Error(`HTTP error! status: ${response.status}`));
          }
        },
        onerror: (error) => {
          transportLogger.error(`[Fetch] Erro na requisi\xE7\xE3o GM_xmlhttpRequest:`, error);
          mobx.runInAction(() => {
            state.incomingResources.wood = 0;
            state.incomingResources.stone = 0;
            state.incomingResources.iron = 0;
          });
          reject(error);
        },
        ontimeout: () => {
          transportLogger.error("[Fetch] Requisi\xE7\xE3o para transportes expirou (timeout).");
          mobx.runInAction(() => {
            state.incomingResources.wood = 0;
            state.incomingResources.stone = 0;
            state.incomingResources.iron = 0;
          });
          reject(new Error("Transport request timed out"));
        }
      });
    });
  }
  const calculateSellAmount = (resource, merchantsAvailable) => {
    const marketValue = resource.getMarketValue();
    const total = resource.getTotal();
    const reserveAmount = resource.getReserved();
    const available = Math.max(0, total - reserveAmount);
    const minRate = resource.getReserveRate();
    if (marketValue >= minRate) return 0;
    const sellLimitSelector = `[data-resource="sell-limit${resource.name === "wood" ? "" : `-${resource.name}`}"]`;
    const sellLimitInput = document.querySelector(sellLimitSelector);
    const perTransactionLimit = sellLimitInput ? sanitizeNumber(sellLimitInput.value) : Infinity;
    const merchantCapacity = merchantsAvailable * 1e3;
    const grossAmount = Math.min(
      available,
      // Não ultrapassar recursos disponíveis
      merchantCapacity,
      // Limite de carga dos mercadores
      perTransactionLimit
      // Limite por transação do usuário
    );
    const netAmount = Math.floor(grossAmount * 0.9);
    return Math.max(0, netAmount);
  };
  const enforceMerchantLimit = true;
  const unitSize = 100;
  const FIXED_FEE = 100;
  const minProfitThreshold = 1;
  const dataCache = /* @__PURE__ */ new Map();
  let isProcessingSell = false;
  const workerScript = `
self.onmessage = function(e) {
    const { action, data } = e.data;
    switch (action) {
        case 'calculateSellAmount':
            const sellResult = calculateSellAmount(data);
            self.postMessage({ action: 'sellAmountCalculated', result: sellResult });
            break;
        case 'calculateBuyAmount':
            const buyResult = calculateBuyAmount(data); // A l\xF3gica de compra permanece a mesma
            self.postMessage({ action: 'buyAmountCalculated', result: buyResult });
            break;
        default:
            self.postMessage({ error: 'A\xE7\xE3o desconhecida' });
    }
};





function calculateSellAmount(data) {
    const { resources, merchantsAvailable, state, config } = data;

    const resourceData = resources.map(r => {
        const marketRate = r.marketRate;
        const minRate = r.minRate;
        const total = r.total;
        const reserve = r.reserve;
        const available = Math.max(0, total - reserve);
        const sellLimit = r.sellLimit;
        const marketCapacityRaw = r.marketCapacityRaw;
        const dynamicFee = calculateDynamicFee(r, state);
        const maxFromMarket = Math.floor((marketCapacityRaw - config.FIXED_FEE) / (1 + dynamicFee));
        const maxFromStock = Math.floor((available - config.FIXED_FEE) / (1 + dynamicFee));
        const maxFromMerchants = config.enforceMerchantLimit
            ? Math.floor(((merchantsAvailable * 1000) - config.FIXED_FEE) / (1 + dynamicFee))
            : Infinity;
        const effectiveUserLimit = sellLimit === Infinity ? maxFromStock : sellLimit;
        const maxPossible = Math.min(maxFromStock, maxFromMarket, maxFromMerchants, effectiveUserLimit);
        const maxPossibleAdjusted = Math.floor(maxPossible / config.unitSize) * config.unitSize;
        const maxProfit = maxPossibleAdjusted > 0 ? calculateProfit(r, maxPossibleAdjusted) : 0;

        return {
            resource: r,
            marketRate,
            minRate,
            available,
            sellLimit,
            maxPossibleAdjusted,
            maxProfit,
            exchangeRate: r.exchangeRate // Taxa de c\xE2mbio mais recente
        };
    }).filter(r => {
        const effectiveRate = r.marketRate * (1 + (state.marketTrends[r.resource.name] === 'up' ? 0.02 : -0.01));
        return effectiveRate <= r.minRate && r.available > 0;
    }).sort((a, b) => {
        const trendWeightA = state.marketTrends[a.resource.name] === 'down' ? 1.2 : 1;
        const volatilityWeightA = 1 + (state.marketVolatility[a.resource.name] || 0);
        const aScore = a.maxProfit * trendWeightA * volatilityWeightA;

        const trendWeightB = state.marketTrends[b.resource.name] === 'down' ? 1.2 : 1;
        const bVolatilityWeightB = 1 + (state.marketVolatility[b.resource.name] || 0);
        const bScore = b.maxProfit * trendWeightB * bVolatilityWeightB;

        return bScore - aScore || a.exchangeRate - b.exchangeRate;
    });

    if (resourceData.length === 0) {
        return { amountToSell: 0, profit: 0, resourceName: null };
    }

    const topResource = resourceData[0];
    const trendAdjustment = state.marketTrends[topResource.resource.name] === 'up' ? 0.95 : 1.05;
    const dynamicFee = calculateDynamicFee(topResource.resource, state);
    let exchangeRate = topResource.resource.exchangeRate; // Usamos o exchangeRate mais recente

    // Calcula limites iniciais
    const adjustedMarketCapacity = topResource.resource.marketCapacityRaw * trendAdjustment;
    const maxFromMarket = Math.floor((adjustedMarketCapacity - config.FIXED_FEE) / (1 + dynamicFee));
    const maxFromStock = Math.floor((topResource.available - config.FIXED_FEE) / (1 + dynamicFee));
    const maxFromMerchants = config.enforceMerchantLimit
        ? Math.floor(((merchantsAvailable * 1000) - config.FIXED_FEE) / (1 + dynamicFee))
        : Infinity;
    const effectiveUserLimit = topResource.sellLimit === Infinity ? maxFromStock : topResource.sellLimit;

    // Determina a quantidade m\xE1xima poss\xEDvel
    let amountToSell = Math.min(maxFromStock, maxFromMarket, maxFromMerchants, effectiveUserLimit);
    if (amountToSell <= 0) {
        return { amountToSell: 0, profit: 0, resourceName: topResource.resource.name };
    }

    // Garante o lucro m\xEDnimo e ajusta para m\xFAltiplo de exchangeRate
    const minAmountForProfit = Math.ceil(config.minProfitThreshold * exchangeRate);
    amountToSell = Math.max(amountToSell, minAmountForProfit);
    amountToSell = Math.floor(amountToSell / config.unitSize) * config.unitSize;

    if (amountToSell < config.unitSize) {
        return { amountToSell: 0, profit: 0, resourceName: topResource.resource.name };
    }

    // Ajuste otimizado para lucro inteiro e estoque dispon\xEDvel
    let profit = calculateProfit(topResource.resource, amountToSell);
    amountToSell = Math.floor(amountToSell / exchangeRate) * exchangeRate; // M\xFAltiplo de exchangeRate
    profit = calculateProfit(topResource.resource, amountToSell);

    if (profit < config.minProfitThreshold) {
        return { amountToSell: 0, profit: 0, resourceName: topResource.resource.name };
    }

    // Verifica e ajusta o lucro para um valor inteiro vi\xE1vel
    const requiredStock = Math.ceil(amountToSell + config.FIXED_FEE + (amountToSell * dynamicFee));
    if (requiredStock > topResource.available) {
        // Tenta ajustar para o maior lucro inteiro poss\xEDvel dentro do estoque
        let targetProfit = Math.floor(profit);
        while (targetProfit >= config.minProfitThreshold) {
            amountToSell = Math.floor(targetProfit * exchangeRate);
            const requiredStockForTarget = Math.ceil(amountToSell + config.FIXED_FEE + (amountToSell * dynamicFee));
            if (requiredStockForTarget <= topResource.available) {
                profit = targetProfit;
                break;
            }
            targetProfit--;
        }
        if (targetProfit < config.minProfitThreshold) {
            return { amountToSell: 0, profit: 0, resourceName: topResource.resource.name };
        }
    } else if (profit > config.minProfitThreshold) {
        // Tenta alcan\xE7ar o pr\xF3ximo PP inteiro se houver estoque
        const nextProfit = Math.ceil(profit);
        const nextAmount = Math.ceil(nextProfit * exchangeRate);
        const nextRequiredStock = Math.ceil(nextAmount + config.FIXED_FEE + (nextAmount * dynamicFee));
        if (nextRequiredStock <= topResource.available) {
            amountToSell = nextAmount;
            profit = nextProfit;
        }
    }

    // Nova l\xF3gica: Reavalia\xE7\xE3o din\xE2mica baseada em mudan\xE7as recentes do exchangeRate
    const volatility = state.marketVolatility[topResource.resource.name] || 0;
    if (volatility > 0.1) { // Se a volatilidade for alta (>10%), ajusta a venda com cautela
        const adjustmentFactor = state.marketTrends[topResource.resource.name] === 'up' ? 0.9 : 1.1;
        amountToSell = Math.floor(amountToSell * adjustmentFactor / exchangeRate) * exchangeRate;
        profit = calculateProfit(topResource.resource, amountToSell);
        const newRequiredStock = Math.ceil(amountToSell + config.FIXED_FEE + (amountToSell * dynamicFee));
        if (newRequiredStock > topResource.available || profit < config.minProfitThreshold) {
            return { amountToSell: 0, profit: 0, resourceName: topResource.resource.name };
        }
    }

    return { amountToSell, profit, resourceName: topResource.resource.name };
}















function calculateBuyAmount(data) {
    const { resources, effectivePP, storageCapacity, incomingResources, currentResources } = data;

    const resourcesToConsider = resources.map(r => {
        const desiredStock = r.desiredStock || 0;
        const currentStock = currentResources[r.name] || 0;
        const incomingStock = incomingResources[r.name] || 0;
        const totalEffectiveStock = currentStock + incomingStock;

        const deficit = Math.max(0, desiredStock - totalEffectiveStock);
        const availableCapacity = Math.max(0, storageCapacity - totalEffectiveStock);
        const marketRate = r.marketRate || 0;
        const userRateLimit = r.userRateLimit || 0;
        const buyLimitPerTime = r.buyLimitPerTime || Infinity;
        const isRateAcceptable = marketRate > 0 && (userRateLimit === 0 || marketRate >= userRateLimit);

        const costInPP = Math.ceil(deficit / marketRate);
        const affordableAmount = Math.floor(effectivePP * marketRate);

        return {
            name: r.name,
            deficit,
            availableCapacity,
            marketRate,
            userRateLimit,
            isRateAcceptable,
            canPhysicallyBuy: Math.min(deficit, availableCapacity, affordableAmount),
            buyLimitPerTime
        };
    });

    const buyableResources = resourcesToConsider.filter(r =>
        r.deficit > 0 &&
        r.availableCapacity > 0 &&
        r.canPhysicallyBuy > 0 &&
        r.isRateAcceptable
    );

    if (buyableResources.length === 0) {
        return { amountToBuy: 0, resourceName: null };
    }

    buyableResources.sort((a, b) => b.marketRate - a.marketRate);
    const priorityResource = buyableResources[0];

    let buyAmount = Math.min(
        priorityResource.canPhysicallyBuy,
        priorityResource.buyLimitPerTime
    );

    const finalCostPP = Math.ceil(buyAmount / priorityResource.marketRate);
    if (finalCostPP > effectivePP) {
        buyAmount = Math.floor(effectivePP * priorityResource.marketRate);
    }

    buyAmount = Math.max(0, Math.floor(buyAmount));

    return { amountToBuy: buyAmount, resourceName: priorityResource.name };
}




function calculateDynamicFee(resource, state) {
    const marketRate = resource.marketRate;
    const trend = state.marketTrends[resource.name];
    let feePercentage = 0.05;

    if (trend === 'up') feePercentage -= 0.01;
    else if (trend === 'down') feePercentage += 0.015;

    if (marketRate >= 140 && marketRate <= 145) feePercentage = 0.0544;
    else if (marketRate < 120) feePercentage = 0.06;
    else if (marketRate > 150) feePercentage = 0.045;

    return Math.min(Math.max(feePercentage, 0.04), 0.07);
}

function calculateProfit(resource, amountSold) {
    return Math.floor(amountSold / resource.exchangeRate);

}
`;
  const worker = new Worker(URL.createObjectURL(new Blob([workerScript], { type: "text/javascript" })));
  function getResourceElement(resource, selector) {
    const base = resource.name === "wood" ? `[data-resource="${selector}"]` : `[data-resource="${selector}-${resource.name}"]`;
    return document.querySelector(base);
  }
  function getGameDataCached() {
    const cacheKey = "gameData";
    if (dataCache.has(cacheKey)) {
      return dataCache.get(cacheKey);
    }
    const gameData = getGameDataSafely();
    if (gameData) {
      dataCache.set(cacheKey, gameData);
    }
    return gameData;
  }
  function getGameDataSafely() {
    if (typeof TribalWars !== "undefined" && TribalWars.getGameData) {
      try {
        return TribalWars.getGameData();
      } catch (e) {
      }
    }
    return null;
  }
  function getMarketCapacity(resource) {
    const resourceName = resource.name;
    try {
      const gameData = getGameDataSafely();
      if (gameData && gameData.market && gameData.market.capacities && gameData.market.capacities[resourceName]) {
        const capacityData = gameData.market.capacities[resourceName];
        const totalCapacityAPI = capacityData.total || 0;
        const currentStockAPI = capacityData.current || 0;
        const capacityAPI = Math.max(0, totalCapacityAPI - currentStockAPI);
      } else {
      }
    } catch (e) {
      console.error(`[getMarketCapacity - ${resourceName}] Erro ao acessar API TribalWars:`, e);
    }
    try {
      const capacityEl = document.querySelector(`#premium_exchange_capacity_${resourceName}`);
      const stockEl = document.querySelector(`#premium_exchange_stock_${resourceName}`);
      if (capacityEl && stockEl) {
        const capacityText = capacityEl.textContent.trim();
        const stockText = stockEl.textContent.trim();
        const parseNumber = (text) => parseInt(String(text || "0").replace(/[^\d]/g, ""), 10) || 0;
        const totalCapacityDOM = parseNumber(capacityText);
        const currentStockDOM = parseNumber(stockText);
        const capacityDOM = Math.max(0, totalCapacityDOM - currentStockDOM);
        return capacityDOM;
      } else {
        console.warn(`[getMarketCapacity - ${resourceName}] Elementos DOM (#premium_exchange_capacity / #premium_exchange_stock) n\xE3o encontrados.`);
        return 0;
      }
    } catch (e) {
      console.error(`[getMarketCapacity - ${resourceName}] Erro ao ler DOM:`, e);
      return 0;
    }
  }
  function calculateMarketTrend(history) {
    if (history.length < 3) return "neutral";
    const changes = history.slice(-3).map(
      (entry, i, arr) => i > 0 ? entry.rate - arr[i - 1].rate : 0
    );
    const avgChange = changes.reduce((a, b) => a + b, 0) / changes.length;
    if (avgChange > TREND_SENSITIVITY) return "up";
    if (avgChange < -TREND_SENSITIVITY) return "down";
    return "neutral";
  }
  function calculateMarketVolatility(history) {
    if (history.length < 2) return 0;
    const changes = history.slice(-5).map(
      (entry, i, arr) => i > 0 ? Math.abs(entry.rate - arr[i - 1].rate) : 0
    );
    const maxChange = Math.max(...changes);
    const minChange = Math.min(...changes);
    return (maxChange - minChange) / 100;
  }
  function updateMarketAnalysis(resourceName, currentRate) {
    const now = DateTime.now();
    state.rateHistory[resourceName].push({ rate: currentRate, timestamp: now });
    state.rateHistory[resourceName] = state.rateHistory[resourceName].filter(
      (entry) => now.diff(entry.timestamp, "minutes").minutes <= VOLATILITY_WINDOW
    );
    state.marketTrends[resourceName] = calculateMarketTrend(state.rateHistory[resourceName]);
    state.marketVolatility[resourceName] = calculateMarketVolatility(state.rateHistory[resourceName]);
    state.lastUpdate[resourceName] = now.toLocaleString(DateTime.DATETIME_SHORT);
  }
  function getMarketRate(resource) {
    if (!resource || !resource.name) {
      return 100;
    }
    const selector = `#premium_exchange_rate_${resource.name} > div:nth-child(1)`;
    const rateElement = document.querySelector(selector);
    if (rateElement) {
      const rateText = rateElement.textContent.trim();
      const rate = parseFloat(rateText.replace(/[^0-9.]/g, "")) || 100;
      dataCache.set(`rate_${resource.name}`, rate);
      updateMarketAnalysis(resource.name, rate);
      return rate;
    }
    const cacheKey = `rate_${resource.name}`;
    if (dataCache.has(cacheKey)) {
      const cachedRate = dataCache.get(cacheKey);
      updateMarketAnalysis(resource.name, cachedRate);
      return cachedRate;
    }
    const gameData = getGameDataCached();
    if (gameData && gameData.market && gameData.market.rates) {
      const rate2 = gameData.market.rates[resource.name];
      if (rate2 !== void 0) {
        const parsedRate = parseFloat(rate2) || 100;
        dataCache.set(cacheKey, parsedRate);
        updateMarketAnalysis(resource.name, parsedRate);
        return parsedRate;
      }
    }
    updateMarketAnalysis(resource.name, 100);
    return 100;
  }
  const rateElements = {
    wood: document.querySelector("#premium_exchange_rate_wood > div:nth-child(1)"),
    stone: document.querySelector("#premium_exchange_rate_stone > div:nth-child(1)"),
    iron: document.querySelector("#premium_exchange_rate_iron > div:nth-child(1)")
  };
  const rateObservers = {};
  function setupMarketRateObservers() {
    Object.entries(rateElements).forEach(([resource, element]) => {
      if (element) {
        const observer = new MutationObserver(() => {
          const newRate = sanitizeNumber(element.textContent.trim().replace(/[^0-9.]/g, "")) || 100;
          dataCache.set(`rate_${resource}`, newRate);
          updateMarketAnalysis(resource, newRate);
          if (state.sellModeActive && !isProcessingSell) {
            updateSell();
          }
          if (state.buyModeActive && !isProcessingBuy) {
            processBuyBasedOnResources();
          }
        });
        observer.observe(element, { childList: true, subtree: true, characterData: true });
        rateObservers[resource] = observer;
      } else {
        console.warn(`${SCRIPT_NAME}: Elemento da taxa de mercado para ${resource} n\xE3o encontrado.`);
      }
    });
  }
  function getSellLimit(resource) {
    const cacheKey = `sellLimit_${resource.name}`;
    if (dataCache.has(cacheKey)) {
      return dataCache.get(cacheKey);
    }
    const sellInputEl = getResourceElement(resource, "sell-limit");
    if (!sellInputEl) {
      return Infinity;
    }
    const val = parseInt(sellInputEl.value, 10);
    const result = isNaN(val) || val <= 0 ? Infinity : val;
    dataCache.set(cacheKey, result);
    return result;
  }
  function getDynamicFee(resource) {
    const marketRate = getMarketRate(resource);
    const trend = state.marketTrends[resource.name];
    let feePercentage = 0.05;
    if (trend === "up") {
      feePercentage -= 0.01;
    } else if (trend === "down") {
      feePercentage += 0.015;
    }
    if (marketRate >= 140 && marketRate <= 145) {
      feePercentage = 0.0544;
    } else if (marketRate < 120) {
      feePercentage = 0.06;
    } else if (marketRate > 150) feePercentage = 0.045;
    return Math.min(Math.max(feePercentage, 0.04), 0.07);
  }
  function getExchangeRate(resource) {
    const cacheKey = `exchange_${resource.name}`;
    const selector = `#premium_exchange_rate_${resource.name} .premium-exchange-sep`;
    const rateEl = document.querySelector(selector);
    if (rateEl) {
      const rateText2 = rateEl.textContent.trim();
      const rate2 = parseFloat(rateText2.replace(/[^0-9.]/g, "")) || 1;
      dataCache.set(cacheKey, rate2);
      return rate2;
    }
    if (dataCache.has(cacheKey)) {
      return dataCache.get(cacheKey);
    }
    const gameData = getGameDataCached();
    if (gameData && gameData.market && gameData.market.exchangeRates) {
      const exchangeRate = gameData.market.exchangeRates[resource.name];
      if (exchangeRate !== void 0) {
        const parsedRate = parseFloat(exchangeRate) || 1;
        dataCache.set(cacheKey, parsedRate);
        return parsedRate;
      }
    }
    if (!rateEl) {
      return 1;
    }
    const rateText = rateEl.textContent.trim();
    const rate = parseFloat(rateText.replace(/[^0-9.]/g, "")) || 1;
    dataCache.set(cacheKey, rate);
    return rate;
  }
  function calculateProfit(resource, amountSold) {
    const exchangeRate = getExchangeRate(resource);
    const rate = resource.exchangeRate || getExchangeRate(resource);
    return Math.floor(amountSold / rate);
  }
  function getMerchantsAvailable() {
    const merchantsElement = document.querySelector("#market_merchant_available_count");
    if (merchantsElement) {
      return sanitizeNumber(merchantsElement.textContent);
    }
    return 0;
  }
  function setupMerchantsObserver() {
    const merchantsElement = document.querySelector("#market_merchant_available_count");
    if (merchantsElement) {
      const observer = new MutationObserver(() => {
        const merchantsAvailable = getMerchantsAvailable();
        if (state.sellModeActive && !isProcessingSell) {
          updateSell();
        }
      });
      observer.observe(merchantsElement, { childList: true, subtree: true, characterData: true });
      resourceObservers.merchants = observer;
    } else {
      console.warn(`${SCRIPT_NAME}: Elemento de contagem de mercadores (#market_merchant_available_count) n\xE3o encontrado.`);
    }
  }
  function setupPremiumObserver() {
    const premiumElement = document.querySelector("#premium_points");
    if (!premiumElement) {
      console.warn(`${SCRIPT_NAME}: Elemento de Pontos Premium (#premium_points) n\xE3o encontrado para observa\xE7\xE3o.`);
      return;
    }
    const premiumObserver = new MutationObserver(() => {
      if (state.buyModeActive && !isProcessingBuy) {
        processBuyBasedOnResources();
      }
    });
    premiumObserver.observe(premiumElement, {
      childList: true,
      // Observa se o texto dentro muda
      subtree: true,
      // Observa mudanças nos filhos também (caso o número esteja em um <span>)
      characterData: true
      // Importante para detectar mudança no texto do nó
    });
  }
  function setupStorageObserver() {
    const storageElement = document.querySelector("#storage") || document.getElementById("storage");
    if (!storageElement) {
      console.warn(`${SCRIPT_NAME}: Elemento de Armaz\xE9m (#storage) n\xE3o encontrado para observa\xE7\xE3o.`);
      return;
    }
    const getStorageCapacityFromDOM = () => {
      const capacityElement = document.getElementById("storage");
      if (capacityElement) {
        const text = capacityElement.textContent || "";
        const match = text.match(/(\d[\d.,]*)\s*\/\s*(\d[\d.,]*)/) || text.match(/(\d[\d.,]*)/);
        if (match && match[2]) {
          return sanitizeNumber(match[2].replace(/[.,]/g, ""));
        } else if (match && match[1]) {
          return sanitizeNumber(match[1].replace(/[.,]/g, ""));
        }
      }
      console.warn(`${SCRIPT_NAME}: N\xE3o foi poss\xEDvel ler a capacidade m\xE1xima do armaz\xE9m do DOM.`);
      return state.storageCapacity || 1e3;
    };
    const storageObserver = new MutationObserver(() => {
      const newCapacity = getStorageCapacityFromDOM();
      if (newCapacity !== state.storageCapacity) {
        state.storageCapacity = newCapacity;
        if (state.buyModeActive && !isProcessingBuy) {
          processBuyBasedOnResources();
        }
      } else {
      }
    });
    storageObserver.observe(storageElement, {
      childList: true,
      subtree: true,
      characterData: true
    });
  }






/**
 * Função principal para lógica de venda de recursos.
 * Verifica se a venda está ativa, se há mercadores e se não está em cooldown ou processando.
 * Coleta dados atuais, envia para o Worker calcular a melhor venda,
 * e valida o resultado do Worker contra o estado atual ANTES de executar a transação.
 */
function updateSell() {
    // 1. Verificações Iniciais (Guard Clauses)
    if (isSellCooldownActive) {
        return;
    }
    if (!state.sellModeActive) {
        return;
    }
    if (isProcessingSell) {
        return;
    }

    const merchantsAvailableInitial = getMerchantsAvailable(); // Pega mercadores ANTES de iniciar o processamento
    if (enforceMerchantLimit && merchantsAvailableInitial <= 0) { // Verifica se *precisa* de mercadores e se há algum
        return; // Não adianta prosseguir se não há mercadores e o limite está ativo
    }

    // 2. Marcar como Processando
    isProcessingSell = true;
    // console.log(`[Venda] Processo iniciado. Mercadores iniciais: ${merchantsAvailableInitial}`); // Log removido

    // 3. Coleta de Dados Atuais para o Worker
    const resourcesDataForWorker = Object.values(resources).map((resource) => {
        // Obter os dados mais recentes disponíveis *neste* momento
        const currentTotal = resource.getTotal();
        const currentReserve = resource.getReserved();
        const currentMarketCapacity = getMarketCapacity(resource);
        const currentExchangeRate = getExchangeRate(resource);
        const currentMarketRate = getMarketRate(resource); // Taxa de mercado principal (PP/unidade)
        const currentMinRate = resource.getReserveRate(); // Taxa MÁXIMA que o usuário aceita vender
        const currentSellLimit = getSellLimit(resource);

        return {
            name: resource.name,
            marketRate: currentMarketRate,
            minRate: currentMinRate,
            total: currentTotal,
            reserve: currentReserve,
            sellLimit: currentSellLimit,
            marketCapacityRaw: currentMarketCapacity,
            exchangeRate: currentExchangeRate
        };
    });

    const workerData = {
        action: "calculateSellAmount",
        data: {
            resources: resourcesDataForWorker,
            merchantsAvailable: merchantsAvailableInitial, // Envia a contagem obtida no início
            state: {
                marketTrends: mobx.toJS(state.marketTrends),
                marketVolatility: mobx.toJS(state.marketVolatility)
            },
            config: {
                enforceMerchantLimit,
                unitSize,
                FIXED_FEE,
                minProfitThreshold
            }
        }
    };

    // 4. Enviar Dados para o Worker
    try {
        // console.log("[Venda] Enviando dados para o Worker calcular a melhor venda..."); // Log removido
        worker.postMessage(workerData);
    } catch (error) {
        // console.error(`${SCRIPT_NAME}: [Venda] Erro CRÍTICO ao enviar mensagem para o Worker:`, error); // Log importante mantido como error
        console.error(`${SCRIPT_NAME}: [Venda] Erro CRÍTICO ao enviar mensagem para o Worker:`, error);
        isProcessingSell = false; // Resetar flag em erro crítico
        return;
    }

    // 5. Manipulação da Resposta do Worker
    worker.onmessage = (e) => {
        // console.log(`[Venda Worker] Resposta recebida: action=${e.data.action}`); // Log removido

        if (e.data.action === "sellAmountCalculated") {
            const { amountToSell, profit, resourceName } = e.data.result;
            // console.log(`[Venda Worker] Resultado: Recurso=${resourceName || 'Nenhum'}, Quantidade=${amountToSell}, Lucro=${profit} PP`); // Log removido

            // 5a. Verificar se o Worker encontrou uma venda válida
            if (amountToSell > 0 && resourceName && resources[resourceName]) {
                const resource = resources[resourceName];

                // ***** INÍCIO: VALIDAÇÃO PRÉ-EXECUÇÃO *****
                // console.log(`[Venda Pre-Val] Iniciando validação final para vender ${amountToSell} ${resourceName}...`); // Log removido

                // ** Re-obter dados CRÍTICOS no último instante **
                const latestTotal = resource.getTotal();
                const reserveAmount = resource.getReserved();
                const currentAvailable = Math.max(0, latestTotal - reserveAmount);
                const currentMerchants = getMerchantsAvailable();
                const requiredMerchants = Math.ceil(amountToSell / 1000);

                // console.log(`[Venda Pre-Val - ${resourceName}] Proposto: ${amountToSell}, Disponível Atual: ${currentAvailable} (Total: ${latestTotal}, Reserva: ${reserveAmount}), Mercadores Atuais: ${currentMerchants}, Necessários: ${requiredMerchants}`); // Log removido

                // ** A Verificação Final **
                if (amountToSell <= currentAvailable && (!enforceMerchantLimit || currentMerchants >= requiredMerchants)) {
                    // Validação PASSOU! Prosseguir com a transação
                    // console.log(`[Venda] Validação PRÉ-EXECUÇÃO PASSOU para ${amountToSell} ${resourceName}. Executando transação...`); // Log removido

                    isSellCooldownActive = true;
                    // console.log(`[Venda] Cooldown de venda de ${SELL_COOLDOWN_MS / 1000}s iniciado.`); // Log removido
                    setTimeout(() => {
                        isSellCooldownActive = false;
                        // console.log(`[Venda] Cooldown de venda finalizado.`); // Log removido
                    }, SELL_COOLDOWN_MS);

                    executeTransaction("sell", resource, amountToSell);
                    notifyUser(`${i18n.t("profit")}: ${profit} PP`, "success");

                    // Não resetamos isProcessingSell aqui, esperando o fluxo normal (reload)

                } else {
                    // Validação FALHOU!
                    let reason = "";
                    if (amountToSell > currentAvailable) {
                        reason = `Recursos insuficientes (${currentAvailable} disponíveis < ${amountToSell} proposto).`;
                    } else {
                        reason = `Mercadores insuficientes (${currentMerchants} disponíveis < ${requiredMerchants} necessários).`;
                    }
                    // console.warn(`[Venda] Transação de ${amountToSell} ${resourceName} CANCELADA na pré-validação. Motivo: ${reason}`); // Log importante mantido como warn
                    console.warn(`[Venda] Transação de ${amountToSell} ${resourceName} CANCELADA na pré-validação. Motivo: ${reason}`);
                    isProcessingSell = false; // *** ESSENCIAL: Resetar a flag para permitir novas tentativas ***
                }
                // ***** FIM: VALIDAÇÃO PRÉ-EXECUÇÃO *****

            } else {
                // Worker não calculou nenhuma venda válida
                // console.log("[Venda] Worker não encontrou nenhuma venda lucrativa/válida para executar."); // Log removido
                isProcessingSell = false; // Resetar a flag, pois este ciclo de venda terminou sem ação
            }

        } else if (e.data.error) {
            // console.error(`${SCRIPT_NAME}: [Venda Worker] Erro recebido do Worker:`, e.data.error); // Log importante mantido como error
             console.error(`${SCRIPT_NAME}: [Venda Worker] Erro recebido do Worker:`, e.data.error);
            isProcessingSell = false; // Resetar a flag em caso de erro no worker
        } else {
            // console.warn("[Venda Worker] Mensagem desconhecida recebida do Worker:", e.data); // Log removido
            isProcessingSell = false; // Resetar por segurança
        }

    }; // Fim de worker.onmessage

    // 6. Manipulação de Erro Geral do Worker
    worker.onerror = (error) => {
        // console.error(`${SCRIPT_NAME}: [Venda] Erro GERAL no Worker:`, error); // Log importante mantido como error
        console.error(`${SCRIPT_NAME}: [Venda] Erro GERAL no Worker:`, error);
        isProcessingSell = false; // Resetar a flag em caso de erro geral no worker
    };

} // Fim da função updateSell











  const debouncedUpdateSell = _.debounce(updateSell, 100);
  const updateAll = () => {
    if (state.buyModeActive) {
      Object.values(resources).forEach((resource) => processBuyBasedOnResources());
      if (!state.hasExecutedBuy) processBuyBasedOnResources();
    }
    if (state.sellModeActive) debouncedUpdateSell();
  };
  const setupEvents = () => {
    const debounceDelay = 300;
    Object.values(resources).forEach((resource) => {
      if (resource.config.uiRateInput) {
        resource.config.uiRateInput.addEventListener("input", _.debounce(() => {
          processBuyBasedOnResources();
          if (state.buyModeActive && !state.hasExecutedBuy) processBuyBasedOnResources();
        }, debounceDelay));
      }
      if (resource.config.uiReserveRateInput) {
        resource.config.uiReserveRateInput.addEventListener("input", _.debounce(updateSell, debounceDelay));
      }
    });
    ui.getElement("buyPerTimeInput").addEventListener("input", _.debounce(updateAll, debounceDelay));
    ui.getElement("storageLimitInput").addEventListener("input", _.debounce(updateAll, debounceDelay));
    ui.getElement("maxSpendInput").addEventListener("input", _.debounce(updateAll, debounceDelay));
    ui.getElement("sellLimitInput").addEventListener("input", _.debounce(updateSell, debounceDelay));
    ui.getElement("buyModeToggle").addEventListener("click", () => toggleMode("buyModeActive"));
    ui.getElement("sellModeToggle").addEventListener("click", () => toggleMode("sellModeActive"));
    ui.getElement("buyPause").addEventListener("click", () => {
      if (state.buyModeActive) {
        state.buyModeActive = false;
        localStorage.setItem("buyModeActive", state.buyModeActive);
        state.hasExecutedBuy = false;
        updateUI();
        notifyUser(i18n.t("deactivated"), "warning");
      }
    });
    ui.getElement("sellPause").addEventListener("click", () => {
      if (state.sellModeActive) {
        state.sellModeActive = false;
        localStorage.setItem("sellModeActive", state.sellModeActive);
        state.hasExecutedSell = false;
        updateUI();
        notifyUser(i18n.t("deactivated"), "warning");
      }
    });
    ui.getElement("sellPause").addEventListener("click", () => {
      if (state.sellModeActive) {
        state.sellModeActive = false;
        localStorage.setItem("sellModeActive", state.sellModeActive);
        state.hasExecutedSell = false;
        updateUI();
        notifyUser(i18n.t("deactivated"), "warning");
      }
    });
    ui.getElement("saveConfig").addEventListener("click", () => {
      const configData = {};
      const inputs = ui.getElement("inputs") || [];
      inputs.forEach((input) => {
        if (!input || !input.dataset?.resource) return;
        const value = input.value.trim();
        const sanitizedValue = sanitizeNumber(value);
        const dataResource = input.dataset.resource;
        if (value && !isNaN(sanitizedValue) && sanitizedValue >= 0) {
          configData[dataResource] = String(sanitizedValue);
        }
      });
      const specialInputs = [
        { id: "buyPerTimeInput", key: "buy-per-time" },
        { id: "storageLimitInput", key: "storage-limit" },
        { id: "maxSpendInput", key: "max-spend" }
      ];
      specialInputs.forEach(({ id, key }) => {
        const input = ui.getElement(id);
        if (input && input.value.trim()) {
          const value = sanitizeNumber(input.value.trim());
          if (!isNaN(value) && value >= 0) {
            configData[key] = String(value);
          }
        }
      });
      const premiumInput = ui.getElement("premiumPointsInput");
      if (premiumInput) {
        const premiumValue = premiumInput.value.trim();
        if (premiumValue !== "") {
          const sanitizedValue = sanitizeNumber(premiumValue);
          if (!isNaN(sanitizedValue)) {
            configData.premiumPoints = String(Math.max(0, sanitizedValue));
          }
        }
      }
      try {
        const compressedConfig = LZString.compress(JSON.stringify(configData));
        localStorage.setItem("compressedConfig", compressedConfig);
        localStorage.setItem("language", state.language);
        notifySuccess(i18n.t("saveSuccess"));
      } catch (error) {
        console.error("[SaveConfig] Erro ao salvar configura\xE7\xE3o:", error);
        notifyError("Erro ao salvar configura\xE7\xE3o");
      }
    });
    ui.getElement("resetAll").addEventListener("click", () => {
      ui.getElement("inputs").forEach((input) => {
        input.value = "";
        localStorage.removeItem(input.dataset.resource);
      });
      state.buyModeActive = state.sellModeActive = state.hasExecutedBuy = state.hasExecutedSell = false;
      localStorage.setItem("buyModeActive", "false");
      localStorage.setItem("sellModeActive", "false");
      updateUI();
      resetBuyInputs();
      notifySuccess(i18n.t("saveSuccess"));
    });
    ui.getElement("transactionsBtn").addEventListener("click", showTransactions);
    ui.getElement("languageSelect").addEventListener("change", (e) => {
      const newLang = e.target.value;
      if (["pt", "ru", "en"].includes(newLang)) {
        state.language = newLang;
        i18n.changeLanguage(newLang);
        localStorage.setItem("language", state.language);
        updateUI();
        if (ui.getElement("transactionsModal").style.display === "flex" && state.transactions) {
          renderTransactionsModal(mobx.toJS(state.transactions), {}, "date", "desc", 1, 10);
        }
      }
    });
    ui.getElement("villageSelect").addEventListener("change", (e) => {
      if (e.target.value === "current") updateVillageInfo();
    });
    ui.getElement("aiAssistantBtn").addEventListener("click", () => {
      ui.getElement("aiModal").style.display = "flex";
      ui.getElement("aiPrompt").value = "";
      ui.getElement("aiResponse").innerHTML = "";
    });
    ui.getElement("submitAI").addEventListener("click", async () => {
      const prompt = ui.getElement("aiPrompt").value;
      if (!prompt.trim()) return;
      ui.getElement("aiResponse").innerHTML = `<p>${i18n.t("aiLoading")}</p>`;
      try {
        const response = await callGeminiAPI(prompt);
        ui.getElement("aiResponse").innerHTML = `<p>${response}</p>`;
      } catch (error) {
        ui.getElement("aiResponse").innerHTML = `<p>${i18n.t("aiError")}: ${error}</p>`;
      }
    });
    ui.getElement("closeAIModal").addEventListener("click", () => {
      ui.getElement("aiModal").style.display = "none";
    });
    ui.getElement("settingsBtn").addEventListener("click", () => {
     populateUserInfo(); // <<< ADICIONE ESTA LINHA AQUI
     state.isSettingsModalOpen = !state.isSettingsModalOpen;
     ui.getElement("settingsModal").style.display = state.isSettingsModalOpen ? "flex" : "none";
    });
    ui.getElement("closeSettingsModal").addEventListener("click", () => {
      state.isSettingsModalOpen = false;
      ui.getElement("settingsModal").style.display = "none";
    });
    ui.getElement("minimizeButton").addEventListener("click", () => {
      state.isMinimized = true;
      const container = ui.getElement("market-container");
      const minimizedBox = ui.getElement("minimizedMarketBox");
      container.style.display = "none";
      minimizedBox.style.display = "block";
      localStorage.setItem("isMinimized", true);
    });
    ui.getElement("minimizedMarketBox").addEventListener("click", () => {
      state.isMinimized = false;
      const container = ui.getElement("market-container");
      const minimizedBox = ui.getElement("minimizedMarketBox");
      container.style.display = "block";
      minimizedBox.style.display = "none";
      localStorage.setItem("isMinimized", false);
    });
    document.querySelectorAll(".rate-input").forEach((input) => {
      input.addEventListener("mouseenter", (e) => {
        const tooltipKey = e.target.dataset.tooltip;
        const resource = e.target.dataset.resource.split("-")[0];
        const text = i18n.t(tooltipKey, { resource: i18n.t(resource) });
        showTooltip(e, text);
      });
      input.addEventListener("mousemove", (e) => {
        updateTooltipPosition(e);
      });
      input.addEventListener("mouseleave", hideTooltip);
    });
  };








   const updateUI = () => {
    // --- Atualizações Fora da Modal (Seu código existente) ---
    const buyToggle = ui.getElement("buyModeToggle");
    if (buyToggle) {
        buyToggle.textContent = i18n.t(state.buyModeActive ? "buyModeToggleOn" : "buyModeToggleOff");
        buyToggle.className = `black-btn toggle-btn ${state.buyModeActive ? "active" : "inactive"}`;
    }
    const buyStatus = ui.getElement("buyStatus");
    if (buyStatus) {
        buyStatus.textContent = i18n.t(state.buyModeActive ? "activated" : "deactivated");
        buyStatus.className = `status ${state.buyModeActive ? "green" : "red"}`;
    }
    const sellToggle = ui.getElement("sellModeToggle");
    if (sellToggle) {
        sellToggle.textContent = i18n.t(state.sellModeActive ? "sellModeToggleOn" : "sellModeToggleOff");
        sellToggle.className = `black-btn toggle-btn ${state.sellModeActive ? "active" : "inactive"}`;
    }
    const sellStatus = ui.getElement("sellStatus");
    if (sellStatus) {
        sellStatus.textContent = i18n.t(state.sellModeActive ? "activated" : "deactivated");
        sellStatus.className = `status ${state.sellModeActive ? "green" : "red"}`;
    }
    const buyPause = ui.getElement("buyPause");
    if (buyPause) buyPause.textContent = i18n.t("pause");

    const sellPause = ui.getElement("sellPause");
    if (sellPause) sellPause.textContent = i18n.t("pause");

    const headerTitle = ui.getElement("headerTitle");
    if (headerTitle) headerTitle.textContent = i18n.t("title");

    const saveConfig = ui.getElement("saveConfig"); // Botão Salvar principal
    if (saveConfig) saveConfig.textContent = i18n.t("saveConfig");

    const resetAll = ui.getElement("resetAll");
    if (resetAll) resetAll.textContent = `\u21BB ${i18n.t("resetAll")}`;

    const transactionsBtn = ui.getElement("transactionsBtn");
    if (transactionsBtn) transactionsBtn.textContent = i18n.t("transactions");

    const settingsBtn = ui.getElement("settingsBtn"); // Ícone de engrenagem
    if (settingsBtn) settingsBtn.innerHTML = `<i class="fa-solid fa-gear"></i>`;

    const worldProfit = ui.getElement("worldProfit"); // Lucro no header
    if (worldProfit) worldProfit.textContent = state.worldProfit; // Não traduzido, é um número

    // Atualiza as opções do select de idioma principal (se ainda existir fora da modal)
    // ou o select DENTRO da modal
    const languageSelect = ui.getElement("languageSelect"); // Pega o select pelo ID
    if (languageSelect) {
        languageSelect.innerHTML = `
            <option value="pt" ${state.language === "pt" ? "selected" : ""}>\u{1F1F5}\u{1F1F9} ${i18n.t("portuguese")}</option>
            <option value="ru" ${state.language === "ru" ? "selected" : ""}>\u{1F1F7}\u{1F1FA} ${i18n.t("russian")}</option>
            <option value="en" ${state.language === "en" ? "selected" : ""}>\u{1F1EC}\u{1F1E7} ${i18n.t("english")}</option>
            `;
         // Adicionar mais options aqui se houver mais idiomas
    }

     // --- ATUALIZAÇÕES DENTRO DA MODAL DE CONFIGURAÇÕES ---
     const settingsModal = document.getElementById('settingsModal');
     if (settingsModal) { // Só tenta atualizar se a modal existir

         // Atualiza todos os elementos com data-i18n-key
         const elementsToTranslate = settingsModal.querySelectorAll('[data-i18n-key]');
         elementsToTranslate.forEach(el => {
             const key = el.dataset.i18nKey;
             if (key) {
                 el.textContent = i18n.t(key); // Atualiza o texto principal
             }
         });

         // Atualiza atributos 'title' que precisam de tradução
         const elementsWithTitle = settingsModal.querySelectorAll('[data-i18n-key-title]');
         elementsWithTitle.forEach(el => {
             const key = el.dataset.i18nKeyTitle;
             if (key) {
                 el.title = i18n.t(key); // Atualiza o atributo title
             }
         });

         // Atualiza placeholders se necessário (exemplo)
         // const checkIntervalInput = settingsModal.querySelector('#checkIntervalInput');
         // if (checkIntervalInput) {
         //     checkIntervalInput.placeholder = i18n.t('settingsPlaceholderCheckInterval'); // Precisa da chave de tradução
         // }

         // Atualiza as opções do select de idioma DENTRO da modal (redundante se o código acima já o fez)
         // O código acima para languageSelect já deve ter atualizado se o ID for o mesmo.

     }


    // -- Atualiza Tooltips (se a lógica estiver aqui) --
    // Se a atualização dos tooltips depender de i18n, ela deve ser chamada aqui também.
    // Exemplo: updateAllTooltips();

   // Fim de updateUI
    const minimizeButton2 = ui.getElement("minimizeButton");
    if (minimizeButton2) {
      minimizeButton2.title = i18n.t("minimize");
    }
  };
  const loadConfig = () => {
    const compressedConfig = localStorage.getItem("compressedConfig");
    if (compressedConfig) {
      try {
        const decompressedConfig = LZString.decompress(compressedConfig);
        const configData = JSON.parse(decompressedConfig);
        document.querySelectorAll(".rate-input").forEach((input) => {
          const dataResource = input.dataset.resource;
          if (configData[dataResource]) {
            input.value = configData[dataResource];
          }
        });
        if (configData.premiumPoints) {
          const premiumInput = ui.getElement("premiumPointsInput");
          if (premiumInput) {
            premiumInput.value = configData.premiumPoints;
          }
        }
        const buyPerTimeInput = ui.getElement("buyPerTimeInput");
        if (buyPerTimeInput && configData["buy-per-time"]) {
          buyPerTimeInput.value = configData["buy-per-time"];
        }
        const storageLimitInput = ui.getElement("storageLimitInput");
        if (storageLimitInput && configData["storage-limit"]) {
          storageLimitInput.value = configData["storage-limit"];
        }
        const maxSpendInput = ui.getElement("maxSpendInput");
        if (maxSpendInput && configData["max-spend"]) {
          maxSpendInput.value = configData["max-spend"];
        }
      } catch (error) {
        console.error(`[LoadConfig] Erro ao carregar configura\xE7\xE3o:`, error);
      }
    } else {
    }
  };
  let resources;
  const resourceObservers = {};
  const setupResourceObservers = () => {
    const resourceIds = ["wood", "stone", "iron"];
    resourceIds.forEach((resource) => {
      const element = document.querySelector(`#${resource}`);
      if (element) {
        const observer = new MutationObserver(() => {
          const amount = sanitizeNumber(element.textContent);
          if (amount !== currentResources[resource]) {
            currentResources[resource] = amount;
            if (state.buyModeActive && !isProcessingBuy) {
              processBuyBasedOnResources();
            }
            if (state.sellModeActive && !isProcessingSell) {
              updateSell();
            }
          }
        });
        observer.observe(element, { childList: true, subtree: true, characterData: true });
        resourceObservers[resource] = observer;
      } else {
        console.warn(`${SCRIPT_NAME}: Elemento de estoque para #${resource} n\xE3o encontrado.`);
      }
    });
  };
  const exchangeRateElements = {
    wood: document.querySelector("#premium_exchange_rate_wood .premium-exchange-sep"),
    stone: document.querySelector("#premium_exchange_rate_stone .premium-exchange-sep"),
    iron: document.querySelector("#premium_exchange_rate_iron .premium-exchange-sep")
  };
  const exchangeRateObservers = {};
  function setupExchangeRateObservers() {
    Object.entries(exchangeRateElements).forEach(([resource, element]) => {
      if (!element) {
        console.error(`Elemento para ${resource} n\xE3o encontrado!`);
        return;
      }
      const observer = new MutationObserver((mutations) => {
        const newRate = sanitizeNumber(
          element.textContent.trim().replace(/[^0-9.,]/g, "").replace(",", ".")
          // Converte vírgula para ponto decimal
        ) || 1;
        dataCache.set(`exchange_${resource}`, newRate);
        if (state.sellModeActive) {
          debouncedUpdateSell();
        }
      });
      observer.observe(element, {
        childList: true,
        subtree: true,
        characterData: true
        // Observa mudanças no texto
      });
      exchangeRateObservers[resource] = observer;
    });
  }












/**
 * Preenche a seção de informações do usuário na modal de configurações
 * com o nome do jogador, data de expiração da licença e versão do script.
 */
function populateUserInfo() {
    const playerNameEl = document.getElementById('settingsPlayerName');
    const licenseExpiryEl = document.getElementById('settingsLicenseExpiry');
    const scriptVersionEl = document.getElementById('settingsScriptVersion');

    // --- Preencher Nome do Jogador ---
    if (playerNameEl) {
        // A variável `currentPlayerNickname` já é definida globalmente
        // quando o script verifica a licença.
        playerNameEl.textContent = currentPlayerNickname || 'Não Encontrado';
    }

    // --- Preencher Data de Expiração da Licença ---
    if (licenseExpiryEl) {
        // Usamos a função `getStoredExpiration` que busca a data salva
        // localmente após a verificação inicial com o Firebase.
        const storedExpiration = getStoredExpiration(currentPlayerNickname);
        if (storedExpiration && !isNaN(storedExpiration.getTime())) { // Verifica se é uma data válida
            try {
                // Formata a data para ficar mais legível (dd/mm/aaaa hh:mm)
                // Usa o idioma atual do script para formatação, se possível.
                licenseExpiryEl.textContent = storedExpiration.toLocaleString(state.language || 'pt-BR', {
                    day: '2-digit', month: '2-digit', year: 'numeric',
                    hour: '2-digit', minute: '2-digit'
                });

                // (Opcional) Adiciona feedback visual se a licença expirou
                const now = new Date();
                licenseExpiryEl.classList.remove('expired'); // Remove classe antiga primeiro
                if (now > storedExpiration) {
                    licenseExpiryEl.classList.add('expired');
                    console.warn("Licença expirada detectada ao popular UI.");
                }

            } catch(e) {
                 console.error("Erro ao formatar data de expiração:", e);
                 licenseExpiryEl.textContent = 'Erro na Data';
                 licenseExpiryEl.classList.remove('expired');
            }
        } else {
            licenseExpiryEl.textContent = 'Não Disponível';
             licenseExpiryEl.classList.remove('expired');
        }
    }

    // --- Preencher Versão do Script ---
    if (scriptVersionEl) {
         // Tenta pegar a versão dinamicamente usando GM_info (padrão Tampermonkey)
        try {
             // @ts-ignore // Ignora erro TS se usar GM.* fora do contexto Tampermonkey
             const scriptInfo = typeof GM_info !== 'undefined' ? GM_info.script : null;
             if (scriptInfo && scriptInfo.version) {
                scriptVersionEl.textContent = scriptInfo.version;
             } else {
                 // Se GM_info não estiver disponível, usa a versão definida no cabeçalho
                 // É importante manter essa string atualizada se mudar a versão no @version
                 scriptVersionEl.textContent = '6.2.0_firebase_auth_persist'; // <-- CONFIRME SE ESTA É A VERSÃO CORRETA
             }
        } catch (e) {
             console.error("Erro ao obter versão do script via GM_info, usando fallback:", e);
             scriptVersionEl.textContent = '6.2.0_firebase_auth_persist'; // Fallback
        }
    }
}























 const GAME_LOAD_TIMEOUT = 5e3;



  const init = async () => {
    try {
      initializeUI();
      if (!initializeElements()) {
        throw new Error("Falha ao inicializar elementos da UI do script RAGNAROK.");
      }
      setupResourceObservers();
      setupMarketRateObservers();
      setupExchangeRateObservers();
      setupMerchantsObserver();
      setupPremiumObserver();
      setupStorageObserver();
      updateVillageInfo();
      applyStyles(); // Aplica estilos CSS
      resources = initializeResources();
      updateGameElements();
      loadConfig(); // Carrega configurações salvas
      setupEvents(); // Configura listeners de eventos
      updateTheme(); // Define o tema (dark/light)
      updateUI(); // Atualiza a UI principal inicial
      await Promise.all([
        fetchResources(), // Busca recursos atuais da aldeia
        fetchIncomingResources() // Busca recursos chegando
      ]);
      await fetchAndUpdateProfit(); // Busca histórico de PP e calcula lucro

      // Limpa intervalos antigos se existirem (prevenção)
      if (state.intervals) {
        clearInterval(state.intervals.resourceInterval);
        clearInterval(state.intervals.transportInterval);
        delete state.intervals;
      }

      await updateAll(); // Executa a lógica inicial de compra/venda

      populateUserInfo(); // <<<---- ADICIONADO AQUI: Preenche informações na modal de Configurações

    } catch (error) {
      console.error(`${SCRIPT_NAME}: Erro durante inicialização:`, error); // Log do erro no console
      notifyError(i18n.t("initError", { error: error.message || String(error) }) + " Verifique o console (F12).");
    }
  };

  const checkGameLoaded = () => {
    // Timeout para garantir que o script não espere indefinidamente
    const timeoutId = setTimeout(() => {
      const merchantsElement = document.querySelector("#market_merchant_available_count");
      const isTribalWarsLoaded = typeof TribalWars !== "undefined" && TribalWars.getGameData;
      if (!(merchantsElement && isTribalWarsLoaded)) {
          clearInterval(gameCheckInterval); // Para o intervalo se o jogo não carregou
          alert(`${SCRIPT_NAME}: Não foi possível iniciar. Elementos essenciais do jogo não foram encontrados após ${GAME_LOAD_TIMEOUT / 1e3} segundos. Recarregue a página ou verifique se há outros scripts conflitando.`);
      }
      // Se chegou aqui, o jogo carregou a tempo e o setInterval já limpou este timeout
    }, GAME_LOAD_TIMEOUT);

    // Verifica periodicamente se os elementos/objetos necessários estão prontos
    const gameCheckInterval = setInterval(() => {
      try {
        const merchantsElement = document.querySelector("#market_merchant_available_count");
        const isTribalWarsLoaded = typeof TribalWars !== "undefined" && TribalWars.getGameData;
        const isSortableLoaded = typeof Sortable !== "undefined";
        const isMobxLoaded = typeof mobx !== "undefined";
        const isAxiosLoaded = typeof axios !== "undefined";

        // Verifica se tudo necessário carregou
        if (merchantsElement && isTribalWarsLoaded && isSortableLoaded && isMobxLoaded && isAxiosLoaded) {
          clearInterval(gameCheckInterval); // Para de verificar
          clearTimeout(timeoutId); // Cancela o timeout, pois carregou a tempo
          console.log(`${SCRIPT_NAME}: Jogo e dependências carregados. Iniciando o script...`);
          init().catch((error) => { // Chama a inicialização principal
            console.error(`${SCRIPT_NAME}: Erro não capturado durante a execução de init():`, error);
            notifyError(i18n.t("initError", { error: error.message || String(error) }) + " Erro crítico na inicialização.");
          });
        }
      } catch (error) {
        // Ignora erros durante a verificação, pois podem ocorrer antes de tudo carregar
      }
    }, 200); // Verifica a cada 200ms
  };

  // Inicia o processo de verificação
  checkGameLoaded();



  const applyStyles = () => {
    const link = createElement("link", { rel: "stylesheet", href: "https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" });
    document.head.appendChild(link);
    const style = createElement("style");
    style.textContent = `
    /* --- Estilos Gerais do Script --- */
    * { box-sizing: border-box; }
    .market-container {
        padding: 20px;
        border: 2px solid;
        border-radius: 15px;
        width: 900px;
        max-width: 100%;
        margin: 0 auto;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        transition: box-shadow 0.3s ease, opacity 0.3s ease;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        height: auto;
        font-family: 'Roboto', sans-serif;
    }

    .draggable {
        user-select: none;
        touch-action: none;
        transition: transform 0.1s;
    }

    .draggable:active {
        cursor: grabbing !important;
    }

    .market-container.draggable {
        cursor: move;
    }

    .market-container.dark {
        background: linear-gradient(135deg, #1a1a1a, #2d2d2d);
        color: #ffffff;
        border-color: #444;
    }
    .market-container.light {
        background: linear-gradient(135deg, #f0f0f0, #ffffff);
        color: #000000;
        border-color: #ccc;
    }
    .header {
        text-align: center;
        margin-bottom: 15px;
        flex-shrink: 0;
        position: relative;
    }
    .header h2 {
        text-transform: uppercase;
        font-weight: 700;
        margin: 15px 0;
        font-size: 1.5em;
    }
    .market-container.dark .header h2 {
        color: #ffffff;
        text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.7);
    }
    .market-container.light .header h2 {
        color: #000000;
        text-shadow: 1px 1px 3px rgba(255, 255, 255, 0.7);
    }
    .dropdowns {
        display: flex;
        justify-content: space-between;
        width: 100%;
        align-items: center;
    }
    .header-buttons {
        display: flex;
        justify-content: space-between;
        width: 100%;
        position: absolute;
        top: 0px;
        left: 0;
        padding: 0 15px;
        box-sizing: border-box;
        align-items: center;
    }
    .btn-group-left {
        display: flex;
        gap: 6px;
        align-items: center;
    }
    .btn-group-right {
        display: flex;
        gap: 6px;
        align-items: center;
    }
    .left-btn {
        position: relative;
        left: -8px;
        margin-right: auto;
    }
    .profit-info {
        margin-left: auto;
        display: flex;
        align-items: center;
        gap: 8px;
        order: 2;
    }
    .market-container.dark .profit-info {
        color: #ffd700;
    }
    .market-container.light .profit-info {
        color: #b8860b;
    }
    .dropdown {
        display: flex;
        align-items: center;
    }
    .village-icon {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 24px;
        height: 24px;
        margin-right: 8px;
        transition: transform 0.3s ease;
    }
    .village-icon:hover {
        transform: scale(1.1);
    }
    .market-container.dark .village-icon svg path {
        fill: #ffd700;
    }
    .market-container.light .village-icon svg path {
        fill: #b8860b;
    }
    select { /* Estilo base para selects */
        border: 1px solid;
        border-radius: 5px;
        padding: 5px;
        font-size: 14px;
        transition: border-color 0.3s ease;
        box-sizing: border-box;
    }
    .market-container.dark select {
        background-color: #444;
        color: #ffffff;
        border-color: #666;
    }
    .market-container.light select {
        background-color: #e0e0e0;
        color: #000000;
        border-color: #999;
    }
    select:focus {
        border-color: #ffd700; /* Cor alterada para combinar com o tema */
        outline: none;
    }
     .market-container.light select:focus {
         border-color: #b8860b;
     }

    .sections { display: flex; justify-content: space-between; align-items: stretch; flex-grow: 1; margin: 15px 0; }
    .section { width: 48%; padding: 15px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3); transition: transform 0.3s ease; display: flex; flex-direction: column; justify-content: space-between; }
    .market-container.dark .section { background-color: #2a2a2a; }
    .market-container.light .section { background-color: #d0d0d0; }
    .section:hover { transform: translateY(-5px); }
    .section h3 { margin-bottom: 10px; font-size: 16px; font-weight: 700; text-align: left; }
    .market-container.dark .section h3 { color: #ffffff; }
    .market-container.light .section h3 { color: #000000; }
    .status { padding: 2px 8px; border-radius: 4px; font-weight: bold; display: inline-block; }
    .status.green { background-color: #1f7a1f; color: #ffffff; } /* Verde mais escuro */
    .market-container.light .status.green { background-color: #28a745; color: #ffffff; }
    .status.red { background-color: #a32424; color: #ffffff; } /* Vermelho mais escuro */
     .market-container.light .status.red { background-color: #dc3545; color: #ffffff; }
    .base-card { padding: 8px 15px; border-radius: 8px; margin-bottom: 8px; transition: box-shadow 0.3s ease; }
    .resource-card { display: flex; align-items: center; justify-content: flex-start; gap: 5px; flex-wrap: nowrap; cursor: move; }
    .market-container.dark .resource-card { background-color: #3a3a3a; }
    .market-container.light .resource-card { background-color: #e0e0e0; }
    .resource-card:hover { box-shadow: 0 0 10px rgba(255, 215, 0, 0.6); } /* Sombra dourada */
    .resource-card img { width: 24px; height: 24px; margin-right: 3px; }
    .resource-card input { width: 70px; padding: 4px; border: 1px solid; border-radius: 5px; font-size: 14px; transition: border-color 0.3s ease; cursor: text; }
    .market-container.dark .resource-card input { background-color: #555; color: #ffffff; border-color: #777; }
    .market-container.light .resource-card input { background-color: #f0f0f0; color: #000000; border-color: #999; }
    .resource-card input:focus { border-color: #ffd700; outline: none; }
    .market-container.light .resource-card input:focus { border-color: #b8860b; }
    .resource-card span { margin: 0 5px; font-size: 16px; font-weight: bold; transition: color 0.3s ease; }
    .market-container.dark .resource-card span { color: #ffd700; }
    .market-container.light .resource-card span { color: #b8860b; }
    .resource-card:hover span { color: #ffdf80; } /* Dourado mais claro no hover */
    .market-container.light .resource-card:hover span { color: #d4a017; }
    .num-input { display: flex; align-items: center; gap: 3px; margin-left: 5px; flex-shrink: 0; }
    .num-input .resource-icon { width: 24px; height: 24px; margin-right: 3px; }
    .num-input input { width: 70px; padding: 4px; border: 1px solid; border-radius: 5px; font-size: 14px; transition: border-color 0.3s ease; }
    .market-container.dark .num-input input { background-color: #555; color: #ffffff; border-color: #777; }
    .market-container.light .num-input input { background-color: #f0f0f0; color: #000000; border-color: #999; }
    .num-input input:focus { border-color: #ffd700; outline: none; }
    .market-container.light .num-input input:focus { border-color: #b8860b; }
    .buttons { display: flex; justify-content: space-between; align-items: center; margin-top: 10px; gap: 5px; /* Adiciona pequeno espaço */}
    .black-btn { padding: 8px 15px; border: none; border-radius: 5px; cursor: pointer; font-size: 14px; transition: background-color 0.3s ease, transform 0.2s ease; font-weight: bold; }
    .market-container.dark .black-btn { background-color: #333; color: #ffffff; } /* Cor um pouco mais escura */
    .market-container.light .black-btn { background-color: #e0e0e0; color: #000000; border: 1px solid #bbb; }
    .black-btn:hover { transform: scale(1.03) translateY(-1px); } /* Efeito sutil de levantar */
    .market-container.dark .black-btn:hover { background-color: #444; }
    .market-container.light .black-btn:hover { background-color: #d0d0d0; }
    .toggle-btn { padding: 8px 15px; border: none; border-radius: 5px; cursor: pointer; font-size: 14px; transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease; font-weight: bold; }
    .toggle-btn.active { background-color: #1f7a1f; color: #ffffff; box-shadow: 0 0 5px rgba(40, 167, 69, 0.7); } /* Verde mais escuro e sombra */
    .market-container.dark .toggle-btn.active { background-color: #28a745; box-shadow: 0 0 8px rgba(40, 167, 69, 0.9); }
    .toggle-btn.inactive { background-color: #a32424; color: #ffffff; box-shadow: 0 0 5px rgba(220, 53, 69, 0.7); } /* Vermelho mais escuro e sombra */
    .market-container.dark .toggle-btn.inactive { background-color: #dc3545; box-shadow: 0 0 8px rgba(220, 53, 69, 0.9); }
    .toggle-btn:hover { transform: scale(1.03) translateY(-1px); }
    .premium-input-wrapper { display: flex; align-items: center; gap: 5px; } /* Wrapper para o input de PP */
    #premiumPointsInput { width: 70px; padding: 4px; border: 1px solid; border-radius: 5px; font-size: 14px; transition: border-color 0.3s ease; text-align: right; }
    .market-container.dark #premiumPointsInput { background-color: #555; color: #ffffff; border-color: #777; }
    .market-container.light #premiumPointsInput { background-color: #f0f0f0; color: #000000; border-color: #999; }
    #premiumPointsInput:focus { border-color: #ffd700; outline: none; }
    .market-container.light #premiumPointsInput:focus { border-color: #b8860b; }
    .footer { display: flex; justify-content: center; margin-top: 15px; flex-shrink: 0; width: 100%; }
    .footer-buttons-row { display: flex; align-items: center; gap: 10px; background-color: rgba(58, 58, 58, 0.5); padding: 8px 15px; border-radius: 8px; border: 1px solid #555; backdrop-filter: blur(2px); } /* Efeito vidro fosco */
    .market-container.dark .footer-buttons-row { background-color: rgba(58, 58, 58, 0.7); border-color: #555; }
    .market-container.light .footer-buttons-row { background-color: rgba(224, 224, 224, 0.7); border-color: #ccc; }
    .footer-buttons-row .black-btn i { margin-right: 5px; } /* Espaço para ícones nos botões do footer */
    .spinner { width: 20px; height: 20px; border: 3px solid rgba(255, 255, 255, 0.3); border-top: 3px solid #ffd700; border-radius: 50%; animation: spin 1s linear infinite; margin-left: 10px; }
    .market-container.light .spinner { border-color: rgba(0,0,0, 0.2); border-top-color: #b8860b; }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    .notification { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%) translateY(10px); padding: 12px 25px; border-radius: 8px; font-size: 14px; font-weight: bold; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.6); transition: opacity 0.4s ease, transform 0.4s ease; z-index: 2147483647; backdrop-filter: blur(5px); opacity: 0; pointer-events: none; }
    .notification.show { opacity: 1; transform: translateX(-50%) translateY(0); pointer-events: auto; }
    .market-container.dark .notification { color: #ffffff; }
    .market-container.light .notification { color: #000000; }
    .notification.success { background-color: rgba(40, 167, 69, 0.85); border: 1px solid rgba(40, 167, 69, 1); }
    .notification.error { background-color: rgba(220, 53, 69, 0.85); border: 1px solid rgba(220, 53, 69, 1); }
    .notification.warning { background-color: rgba(255, 193, 7, 0.85); border: 1px solid rgba(255, 193, 7, 1); color: #000; } /* Warning com texto preto */

    /* --- Estilos das Modals (Geral) --- */
    .modal {
        position: fixed;
        top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0, 0, 0, 0.7);
        z-index: 2147483646; /* Um pouco abaixo do container principal se ele for arrastável */
        display: flex; justify-content: center; align-items: center;
        backdrop-filter: blur(3px);
        /* Animação de entrada da modal */
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease, visibility 0s linear 0.3s;
    }
    .modal[style*="display: flex"] { /* Aplica animação quando a modal é mostrada */
         opacity: 1;
         visibility: visible;
         transition: opacity 0.3s ease, visibility 0s linear 0s;
    }

    .modal-content { /* Estilo Base para conteúdo das modals */
        border-radius: 10px;
        width: 800px; max-width: 95vw; /* Limita largura */
        max-height: 85vh; /* Limita altura */
        display: flex; flex-direction: column; /* Permite header/body/footer */
        box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
        overflow: hidden; /* Controla overflow no container */
        border: 1px solid #444;
        /* Animação de entrada do conteúdo */
        transform: scale(0.95) translateY(-10px);
        transition: transform 0.3s ease;
    }
    .modal[style*="display: flex"] .modal-content {
         transform: scale(1) translateY(0);
    }

    /* Cores da Modal Base */
    .market-container.dark .modal-content { background: #2a2d32; color: #e0e0e0; border-color: #555; }
    .market-container.light .modal-content { background: #f0f0f0; color: #1a1a1a; border-color: #ccc; }

    /* Scrollbar para conteúdo das modals */
    .modal-content::-webkit-scrollbar, .settings-body::-webkit-scrollbar { width: 8px; height: 8px; }
    .modal-content::-webkit-scrollbar-track, .settings-body::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); border-radius: 4px;}
    .modal-content::-webkit-scrollbar-thumb, .settings-body::-webkit-scrollbar-thumb { background-color: rgba(255, 215, 0, 0.6); border-radius: 4px; transition: background-color 0.3s ease; border: 1px solid rgba(0,0,0,0.2); }
    .modal-content::-webkit-scrollbar-thumb:hover, .settings-body::-webkit-scrollbar-thumb:hover { background-color: rgba(255, 215, 0, 0.8); }
    .market-container.light .modal-content::-webkit-scrollbar-thumb, .market-container.light .settings-body::-webkit-scrollbar-thumb { background-color: rgba(184, 134, 11, 0.6); border-color: rgba(255,255,255,0.2); }
    .market-container.light .modal-content::-webkit-scrollbar-thumb:hover, .market-container.light .settings-body::-webkit-scrollbar-thumb:hover { background-color: rgba(184, 134, 11, 0.8); }


    /* --- Estilos Específicos para a Modal de CONFIGURAÇÕES --- */
    /* Header da Modal de Configurações */
    .settings-header {
        display: flex; justify-content: space-between; align-items: center;
        padding: 15px 20px;
        border-bottom: 1px solid #444;
        flex-shrink: 0; /* Não encolhe */
    }
    .market-container.light .settings-header { border-bottom-color: #ccc; }
    .settings-header h3 { margin: 0; font-size: 1.3em; font-weight: 700; color: #ffd700; }
    .market-container.light .settings-header h3 { color: #b8860b; }
    .settings-header .close-btn { /* Botão Fechar específico do Header */
        background: none; border: none; color: #aaa; font-size: 2.2em;
        line-height: 1; cursor: pointer; padding: 0 5px; transition: color 0.2s ease;
    }
    .settings-header .close-btn:hover { color: #ff4d4d; }
    .market-container.light .settings-header .close-btn { color: #555; }
    .market-container.light .settings-header .close-btn:hover { color: #cc0000; }

    /* Corpo da Modal de Configurações (Scrollável) */
    .settings-body {
        padding: 20px;
        overflow-y: auto; /* Habilita scroll se necessário */
        flex-grow: 1; /* Ocupa o espaço vertical disponível */
    }

    /* Seções dentro do Corpo */
    .settings-section {
        margin-bottom: 25px; padding-bottom: 15px;
        border-bottom: 1px dashed rgba(255, 215, 0, 0.2); /* Divisor dourado transparente */
    }
    .settings-section:last-of-type { margin-bottom: 0; padding-bottom: 0; border-bottom: none; }
    .market-container.light .settings-section { border-bottom-color: rgba(184, 134, 11, 0.2); }

    .settings-section h4 { /* Título da Seção */
        font-size: 1.1em; margin-top: 0; margin-bottom: 15px;
        color: #eee; /* Cor mais clara para subtítulos */
        border-left: 3px solid #ffd700; padding-left: 10px;
        font-weight: bold; text-transform: uppercase; letter-spacing: 0.5px;
    }
    .market-container.light .settings-section h4 { color: #333; border-left-color: #b8860b; }

    /* Seção de Informações do Usuário/Licença */
    .user-info-section .info-row {
        display: flex; justify-content: space-between; align-items: center;
        margin-bottom: 12px; font-size: 0.95em; padding: 8px 5px;
        border-bottom: 1px solid #383838; /* Linha sutil abaixo de cada info */
        transition: background-color 0.2s ease;
    }
    .user-info-section .info-row:last-child { border-bottom: none; margin-bottom: 0;}
    .market-container.light .user-info-section .info-row { border-bottom-color: #e0e0e0; }
    .user-info-section .info-row:hover {
         background-color: rgba(255, 215, 0, 0.05); /* Leve destaque dourado no hover */
    }
    .market-container.light .user-info-section .info-row:hover {
         background-color: rgba(184, 134, 11, 0.05);
    }

    .user-info-section .info-label {
        color: #bbb; display: flex; align-items: center; gap: 8px; /* Mais espaço para ícone */
    }
    .market-container.light .user-info-section .info-label { color: #555; }
    .user-info-section .info-label i.fas { /* Estilo do Ícone FontAwesome */
         font-size: 1em; width: 20px; text-align: center; color: #ffd700; opacity: 0.8;
    }
     .market-container.light .user-info-section .info-label i.fas { color: #b8860b; }

    .user-info-section .info-value {
        font-weight: bold; color: #ffffff; text-align: right;
    }
    .market-container.light .user-info-section .info-value { color: #000000; }
     #settingsLicenseExpiry.expired { /* Classe para expiração */
        color: #ff4d4d !important; font-weight: bold;
    }
     #settingsLicenseExpiry.soon { /* Classe para expirar em breve */
        color: #ffc107 !important; font-weight: bold;
    }

    /* Itens de Configuração Genéricos (Label + Input/Select/Checkbox) */
    .setting-item {
        display: flex; align-items: center; flex-wrap: wrap; /* Permite quebrar linha */
        margin-bottom: 15px; gap: 10px;
        padding: 5px 0; /* Pequeno padding vertical */
    }
    .setting-item label {
        flex-basis: 220px; /* Largura base para o label */
        flex-shrink: 0; /* Não encolhe */
        text-align: right; color: #ccc; font-size: 0.9em;
        display: flex; align-items: center; gap: 6px; /* Ícone dentro do label */
        padding-right: 5px; /* Espacinho antes do input */
    }
     .setting-item label i.fas { /* Ícones nos labels */
         width: 16px; text-align: center; color: #bbb; opacity: 0.7;
     }
    .market-container.light .setting-item label { color: #333; }
     .market-container.light .setting-item label i.fas { color: #666; }

    /* Inputs e Selects dentro das configurações */
    .settings-input,
    #settingsModal select { /* Aplica a ambos */
        flex-grow: 1; min-width: 100px; /* Largura mínima */
        padding: 7px 10px; /* Mais padding */
        border: 1px solid #555; background-color: #3a3a3a;
        color: #e0e0e0; border-radius: 4px; font-size: 0.9em;
        box-sizing: border-box; transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }
    .market-container.light .settings-input,
    .market-container.light #settingsModal select {
        border-color: #aaa; background-color: #fff; color: #1a1a1a;
    }
    .settings-input:focus,
    #settingsModal select:focus {
        border-color: #ffd700; outline: none;
        box-shadow: 0 0 5px rgba(255, 215, 0, 0.5);
    }
    .market-container.light .settings-input:focus,
    .market-container.light #settingsModal select:focus {
         border-color: #b8860b; box-shadow: 0 0 5px rgba(184, 134, 11, 0.5);
    }
    /* Input Numérico pequeno */
    .settings-input[type="number"] {
        width: 80px; /* Tamanho menor para números */
        flex-grow: 0; /* Não expande tanto */
        text-align: right;
    }

    /* Checkboxes */
    .checkbox-item { justify-content: flex-start; }
    .checkbox-item label { flex-basis: auto; text-align: left; cursor: pointer; order: 2; }
    .settings-checkbox { margin: 0; cursor: pointer; order: 1; width: 16px; height: 16px; accent-color: #ffd700; }
    .market-container.light .settings-checkbox { accent-color: #b8860b; }

    /* Ícone de Tooltip (?) */
    .tooltip-icon {
        color: #aaa; cursor: help; font-size: 1.1em;
        transition: color 0.2s ease; margin-left: 5px; /* Espaço após input */
    }
    .tooltip-icon:hover { color: #ffd700; }
    .market-container.light .tooltip-icon { color: #666; }
    .market-container.light .tooltip-icon:hover { color: #b8860b; }

    /* Rodapé da Modal de Configurações */
    .settings-footer {
        padding: 15px 20px;
        border-top: 1px solid #444;
        text-align: right; /* Alinha botões à direita */
        flex-shrink: 0; /* Não encolhe */
        background-color: rgba(30,30,30, 0.5); /* Fundo sutil para o rodapé */
    }
    .market-container.light .settings-footer { border-top-color: #ccc; background-color: rgba(230,230,230, 0.5); }
    /* Botão Salvar dentro da modal (se decidir colocar) */
    .settings-footer .save-settings-btn { /* Usa .black-btn como base */
       /* Estilos específicos se necessário */
       padding: 8px 20px; /* Um pouco maior */
       background-color: #ffd700; /* Dourado para salvar */
       color: #1a1a1a; /* Texto escuro */
       font-weight: bold;
       border: none;
    }
     .settings-footer .save-settings-btn:hover {
         background-color: #e6c200;
         transform: scale(1.03) translateY(-1px);
     }
    .market-container.light .settings-footer .save-settings-btn {
        background-color: #b8860b;
        color: #ffffff;
    }
     .market-container.light .settings-footer .save-settings-btn:hover {
         background-color: #a0740a;
     }


    /* --- Estilos das Outras Modals (Transações, AI) --- */
    /* Estilos para a modal de transações */
    #transactionsModal .modal-content h3, #aiModal .modal-content h3 { /* Título das outras modals */
         padding: 15px 20px; margin:0; text-align: center; border-bottom: 1px solid #444;
         font-size: 1.3em; color: #ffd700;
    }
     .market-container.light #transactionsModal .modal-content h3, .market-container.light #aiModal .modal-content h3 {
         border-bottom-color: #ccc; color: #b8860b;
     }
    #transactionsModal .modal-content > div:not(#paginationControls):not(#transactionsChart), /* Conteúdo da modal de transações */
    #aiModal .modal-content > div:not(:last-child) { /* Conteúdo da modal AI */
         padding: 20px;
         overflow-y: auto;
         flex-grow: 1;
    }
     #transactionsModal .modal-content > div#paginationControls, /* Paginação */
     #aiModal .modal-content > div:last-child { /* Botões AI */
        padding: 15px 20px; border-top: 1px solid #444; text-align: center; flex-shrink: 0;
     }
     .market-container.light #transactionsModal .modal-content > div#paginationControls,
     .market-container.light #aiModal .modal-content > div:last-child {
          border-top-color: #ccc;
     }


    #filterSection { margin-bottom: 15px; display: flex; flex-wrap: wrap; gap: 15px; align-items: center;}
    #filterSection label { display: flex; align-items: center; gap: 5px; margin: 0; font-size: 0.9em; color: #ccc; }
     .market-container.light #filterSection label { color: #333; }
    #filterSection input { padding: 6px 8px; border: 1px solid #555; border-radius: 4px; background: #3a3a3a; color: #e0e0e0; margin: 0; font-size: 0.9em; }
    .market-container.light #filterSection input { border-color: #aaa; background: #fff; color: #1a1a1a; }
    #filterSection input:focus { border-color: #ffd700; outline: none; box-shadow: 0 0 5px rgba(255, 215, 0, 0.5); }
    .market-container.light #filterSection input:focus { border-color: #b8860b; box-shadow: 0 0 5px rgba(184, 134, 11, 0.5); }

    .transactions-table, .ledger-table { width: 100%; border-collapse: collapse; margin-bottom: 15px; font-size: 0.9em; }
    .transactions-table th, .transactions-table td,
    .ledger-table th, .ledger-table td { padding: 8px 10px; border: 1px solid #444; text-align: right; } /* Borda mais escura */
    .market-container.light .transactions-table th, .market-container.light .transactions-table td,
    .market-container.light .ledger-table th, .market-container.light .ledger-table td { border-color: #ddd; }
    .transactions-table th, .ledger-table th { background-color: #333; color: #ffd700; cursor: pointer; text-align: center; font-weight: bold; text-transform: uppercase; letter-spacing: 0.5px;} /* Cabeçalho escuro com texto dourado */
     .market-container.light .transactions-table th, .market-container.light .ledger-table th { background-color: #eee; color: #b8860b; }
    .transactions-table th:hover, .ledger-table th:hover { background-color: #444; }
    .market-container.light .transactions-table th:hover, .market-container.light .ledger-table th:hover { background-color: #ddd; }
    .ledger-table .section-header { background-color: #4d3804; font-weight: bold; color: #ffd700; text-align: center; font-size: 1.1em; } /* Dourado escuro */
    .market-container.light .ledger-table .section-header { background-color: #f0e68c; color: #3b2a03; } /* Khaki claro */
     .ledger-table td:nth-child(3) { font-weight: bold; } /* Destaca coluna de mudança */
     .ledger-table td:nth-child(3) .icon.header.premium { vertical-align: -3px;} /* Ajuste fino ícone */

    #paginationControls { display: flex; justify-content: center; gap: 10px; margin-top: 10px;}
    #transactionsChart { max-width: 100%; margin-top: 15px; display: block; background: rgba(255,255,255,0.05); border-radius: 5px; padding: 10px;}
    .market-container.light #transactionsChart { background: rgba(0,0,0,0.03); }

    /* AI Modal */
    #aiPrompt { resize: vertical; padding: 10px; border: 1px solid #555; border-radius: 5px; width: 100%; margin-bottom: 10px; min-height: 70px; background: #3a3a3a; color: #e0e0e0; font-size: 0.95em; }
    .market-container.light #aiPrompt { border-color: #aaa; background: #fff; color: #1a1a1a; }
    #aiResponse { padding: 15px; border: 1px solid #444; border-radius: 5px; min-height: 120px; margin-bottom: 15px; background: rgba(0,0,0,0.1); font-size: 0.95em; line-height: 1.6; overflow-y: auto; max-height: 300px;}
    .market-container.light #aiResponse { border-color: #ccc; background: rgba(0,0,0,0.03); }
    #aiModal .black-btn { margin: 0 5px; } /* Espaço entre botões AI */


    /* --- Outros Estilos (Sortable, Minimizar, Tooltip, Ícones, Responsivo) --- */
    .icon.header.premium { /* Estilo mantido */ height: 18px; display: inline-block; margin: auto 2px auto 0; overflow: hidden; background-repeat: no-repeat; vertical-align: -4px; background-image: url('https://dsus.innogamescdn.com/asset/95eda994/graphic/icons/header.png'); background-position: -433px 0px; width: 18px; }
    .sortable-container { display: flex; flex-direction: column; gap: 8px; }
    .minimized-box { /* Estilo mantido */ position: fixed; right: 15px; top: 2px; width: 40px; height: 40px; background-color: #2a2d32; border: 2px solid #ffd700; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5); color: #ffffff; font-family: 'Roboto', sans-serif; font-size: 20px; font-weight: 700; display: flex; align-items: center; justify-content: center; border-radius: 8px; cursor: pointer; z-index: 2147483647; transition: transform 0.3s ease, box-shadow 0.3s ease; line-height: 40px; text-align: center; }
    .minimized-box:hover { transform: scale(1.1); box-shadow: 0 6px 20px rgba(255, 215, 0, 0.8); }
    .icon-btn { /* Estilo mantido */ font-size: 1.2em; padding: 2px !important; border: none !important; border-radius: 8px; background: none !important; transition: transform 0.2s ease-in-out, opacity 0.2s ease-in-out; margin-left: 4px !important; opacity: 0.8; fill: currentColor; color: #bbb; }
    .market-container.light .icon-btn { color: #555; }
    .icon-btn:hover { transform: scale(1.1); opacity: 1; transform: translateY(-2px) scale(1.1); }
    .tooltip { /* Estilo mantido */ position: fixed; z-index: 2147483647; background: rgba(42, 42, 50, 0.9); color: #e0e0e0; padding: 10px 15px; border-radius: 6px; border: 1px solid rgba(255, 215, 0, 0.3); box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4); backdrop-filter: blur(5px); font-family: 'Roboto', sans-serif; font-size: 13px; line-height: 1.5; max-width: 280px; width: max-content; transition: opacity 0.3s ease; pointer-events: none; user-select: none; }
    .market-container.light .tooltip { background: rgba(240, 240, 240, 0.9); color: #000000; border-color: rgba(184, 134, 11, 0.4); }

    /* --- Media Queries Responsivas (Mantidas e talvez ajustadas para nova modal) --- */
    @media (max-width: 768px) {
        .market-container { width: 95vw; padding: 15px; font-size: 14px; }
        .modal-content { width: 95vw; max-height: 90vh; } /* Aumenta altura max */
        .header h2 { font-size: 1.2em; margin: 10px 0; }
        .dropdowns { flex-direction: column; gap: 8px; align-items: flex-start; }
        .profit-info { margin-left: 0; margin-top: 5px; }
        .sections { flex-direction: column; gap: 15px; }
        .section { width: 100%; padding: 10px; }
        .base-card { padding: 6px 10px; }
        .resource-card { flex-wrap: wrap; gap: 6px; }
        .resource-card img { width: 20px; height: 20px; }
        .resource-card input, .num-input input { width: 55px; font-size: 12px; padding: 3px; }
        .resource-card span { font-size: 14px; }
        .num-input .resource-icon { width: 20px; height: 20px; }
        .buttons { flex-direction: row; gap: 8px; flex-wrap: wrap; justify-content: center;} /* Botões lado a lado se couber */
        .black-btn, .toggle-btn { padding: 7px 12px; font-size: 12px; }
        .spinner { width: 16px; height: 16px; border-width: 2px; }
        .notification { font-size: 12px; padding: 8px 15px; max-width: 90%; }
        .transactions-table th, .transactions-table td, .ledger-table th, .ledger-table td { font-size: 11px; padding: 5px; }
        .footer-buttons-row { gap: 8px; padding: 6px 12px; }
        #premiumPointsInput { width: 60px; font-size: 12px; padding: 3px; }
        /* Ajustes na modal de settings responsiva */
        .settings-header { padding: 10px 15px; }
        .settings-header h3 { font-size: 1.15em;}
        .settings-header .close-btn { font-size: 2em; }
        .settings-body { padding: 15px; }
        .setting-item { flex-direction: column; align-items: stretch; gap: 5px;} /* Alinha esticado */
        .setting-item label { text-align: left; flex-basis: auto; margin-bottom: 3px; padding-right: 0;}
        .settings-input, #settingsModal select { width: 100%; min-width: none; }
        .settings-input[type="number"] { width: 100px; /* Um pouco maior no mobile */ }
        .user-info-section .info-row { flex-direction: column; align-items: flex-start; gap: 3px; padding: 8px 0;}
        .user-info-section .info-value { text-align: left; }
        #filterSection { gap: 10px; }
        #filterSection label { flex-basis: 100%; } /* Label ocupa linha */
        #filterSection input { width: 100%; }
    }
    @media (max-width: 480px) {
        .market-container { width: 98vw; padding: 10px; font-size: 12px; }
        .modal-content { width: 98vw; }
        .header h2 { font-size: 1.1em; }
        .section h3 { font-size: 14px; }
        .resource-card input, .num-input input { width: 50px; font-size: 11px; }
        .resource-card span { font-size: 13px; }
        .buttons { gap: 6px; }
        .black-btn, .toggle-btn { padding: 6px 10px; font-size: 11px; }
        .spinner { width: 14px; height: 14px; }
        .notification { font-size: 11px; padding: 7px 13px; }
        .transactions-table th, .transactions-table td, .ledger-table th, .ledger-table td { font-size: 10px; padding: 4px; }
        .footer-buttons-row { gap: 6px; padding: 5px 10px; flex-wrap: wrap; }
        #premiumPointsInput { width: 50px; font-size: 11px; padding: 3px; }
         /* Ajustes na modal de settings responsiva */
         .settings-header h3 { font-size: 1.1em;}
         .settings-body { padding: 10px; }
         .settings-section { margin-bottom: 20px; }
         .settings-section h4 { font-size: 1em; }
    }

`; // Fim da string do style.textContent
    document.head.appendChild(style);
};
})();
